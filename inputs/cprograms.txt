



#include "CArray.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void swap(CArray *array, int position1, int position2);

CArray *getCArray(int size)
{
    CArray *array = (CArray *)malloc(sizeof(CArray));
    array->array = (int *)malloc(sizeof(int) * size);
    array->size = size;
    int i;
    for (i = 0; i < size; i++)
    {
        array->array[i] = 0;
    }
    return array;
}

int insertValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] == 0)
        {
            array->array[position] = value;
            return SUCCESS;
        }
        else
            return POSITION_INIT;
    }
    return INVALID_POSITION;
}

int removeValueCArray(CArray *array, int position)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
            array->array[position] = 0;
        }
        else
            return POSITION_EMPTY;
    }
    return INVALID_POSITION;
}

int pushValueCArray(CArray *array, int value)
{
    int i;
    int ok = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == 0)
        {
            array->array[i] = value;
            ok = 1;
            break;
        }
    }
    if (ok == 1)
        return SUCCESS;
    else
        return ARRAY_FULL;
}

int updateValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
        }

        else
            return POSITION_NOT_INIT;
    }
    return INVALID_POSITION;
}

int eraseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size; i++)
    {
        array->array[i] = 0;
    }
    return 0;
}

int switchValuesCArray(CArray *array, int position1, int position2)
{
    if (position1 >= 0 && position1 < array->size && position2 >= 0 &&
        position2 < array->size)
    {
        int temp = array->array[position1];
        array->array[position1] = array->array[position2];
        array->array[position2] = temp;
    }
    return INVALID_POSITION;
}

int reverseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size / 2; i++)
    {
        swap(array, i, array->size - i - 1);
    }
    return SUCCESS;
}

int displayCArray(CArray *array)
{
    int i;
    printf("\nC ARRAY\n");
    for (i = 0; i < array->size; i++)
    {
        printf("%d ", array->array[i]);
    }
    printf("\n");
    return 0;
}

int blenderCArray(CArray *array)
{
    srand(time(NULL) * array->size);
    int i;
    int total = array->size * 100;
    for (i = 0; i < total; i++)
    {
        swap(array, rand() % array->size, rand() % array->size);
    }
    return 0;
}

CArray *getCopyCArray(CArray *arr)
{
    CArray *array = (CArray *)malloc(sizeof(CArray));
    array->array = (int *)malloc(sizeof(int) * arr->size);
    array->size = arr->size;
    int i;
    for (i = 0; i < arr->size; i++)
    {
        array->array[i] = arr->array[i];
    }
    return array;
}

void swap(CArray *array, int position1, int position2)
{
    int temp = array->array[position1];
    array->array[position1] = array->array[position2];
    array->array[position2] = temp;
}

int bubbleSortCArray(CArray *array)
{
    int i, j;
    for (i = 0; i < array->size - 1; i++)
    {
        for (j = 0; j < array->size - i - 1; j++)
        {
            if (array->array[j] > array->array[j + 1])
            {
                swap(array, j, j + 1);
            }
        }
    }
    return 0;
}

int selectionSortCArray(CArray *array)
{
    int i, j, min;
    for (i = 0; i < array->size - 1; i++)
    {
        min = i;
        for (j = i + 1; j < array->size; j++)
            if (array->array[j] < array->array[min])
                min = j;
        swap(array, min, i);
    }
    return 0;
}

int insertionSortCArray(CArray *array)
{
    int i, j, num;
    for (i = 1; i < array->size; i++)
    {
        num = array->array[i];
        j = i - 1;
        while (j >= 0 && array->array[j] > num)
        {
            array->array[j + 1] = array->array[j];
            j--;
        }
        array->array[j + 1] = num;
    }
    return 0;
}

int valueOcurranceCArray(CArray *array, int value)
{
    int i, total = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == value)
            total++;
    }
    return total;
}

CArray *valuePositionsCArray(CArray *array, int value)
{
    int i, j = 0;
    int total = valueOcurranceCArray(array, value);
    CArray *resultArray = getCArray(total);
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == value)
        {
                        resultArray->array[j] = i;
            j++;
        }
    }
    return resultArray;
}

int findMinCArray(CArray *array)
{
    int i;
    int min = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] < min)
        {
            min = array->array[i];
        }
    }
    return min;
}

int findMaxCArray(CArray *array)
{
    int i;
    int max = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] > max)
        {
            max = array->array[i];
        }
    }
    return max;
}


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "CArray.h"

int CArrayTests()
{
    printf("\n");
    printf(" +-------------------------------------+\n");
    printf(" |                                     |\n");
    printf(" |               C Array               |\n");
    printf(" |                                     |\n");
    printf(" +-------------------------------------+\n");
    printf("\n");

    CArray *array = getCArray(10);

    int i;
    for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    printf("Entered array is:\n");
    displayCArray(array);
    printf("\nCode: %d\n", pushValueCArray(array, 11));  
    for (i = 0; i < array->size; i++)
    {
        removeValueCArray(array, i);
    }

    displayCArray(array);

    printf("\nCode: %d", removeValueCArray(array, -1));           printf("\nCode: %d\n", insertValueCArray(array, -1, 1));  
        for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    eraseCArray(array);
    displayCArray(array);  
        CArray *arr = getCArray(13);
    for (i = 0; i < arr->size; i++)
    {
        insertValueCArray(arr, i, i + 1);
    }
    displayCArray(arr);
    for (i = 0; i < arr->size / 2; i++)
    {
        switchValuesCArray(arr, i, arr->size - i - 1);
    }

    displayCArray(arr);

        reverseCArray(arr);

    displayCArray(arr);

        srand(time(NULL));
    CArray *barray = getCArray(20);
    for (i = 0; i < barray->size; i++)
    {
        insertValueCArray(barray, i, rand());
    }
    CArray *carray = getCopyCArray(barray);
    CArray *darray = getCopyCArray(barray);
    printf("\nNot sorted Array:");
    displayCArray(barray);

    printf("\nBubble Sort:");
    clock_t begin1 = clock();
        bubbleSortCArray(barray);
    clock_t end1 = clock();
    double time_spent1 = (double)(end1 - begin1) / CLOCKS_PER_SEC;
    displayCArray(barray);

    printf("\nSelection Sort:");
    clock_t begin2 = clock();
        selectionSortCArray(carray);
    clock_t end2 = clock();
    double time_spent2 = (double)(end2 - begin2) / CLOCKS_PER_SEC;
    displayCArray(carray);

    printf("\nInsertion Sort:");
    clock_t begin3 = clock();
        insertionSortCArray(darray);
    clock_t end3 = clock();
    double time_spent3 = (double)(end3 - begin3) / CLOCKS_PER_SEC;
    displayCArray(carray);

        reverseCArray(barray);
    
            
    printf("\nTotal time spent for bubble sort: %lf seconds", time_spent1);
    printf("\nTotal time spent for selection sort: %lf seconds", time_spent2);
    printf("\nTotal time spent for insertion sort: %lf seconds", time_spent3);

        CArray *aarray = getCArray(1000);
    for (i = 0; i < aarray->size; i++)
    {
        insertValueCArray(aarray, i, rand() % 100);
    }

    int j = 24;
    printf("\nOccurrences of the number %d in the array: %d", j,
           valueOcurranceCArray(aarray, j));
    printf("\nAnd its positions:\n");
    CArray *positions = valuePositionsCArray(aarray, j);
    displayCArray(positions);
        printf("\nAll %d s", j);
    for (i = 0; i < positions->size; i++)
    {
        printf("\nPosition %d has a value of %d", positions->array[i],
               aarray->array[positions->array[i]]);
    }
    printf("\nThe list has a minimum value of %d and a maximum value of %d",
           findMinCArray(aarray), findMaxCArray(aarray));
    insertionSortCArray(aarray);
    
    free(arr);
    free(array);
    free(aarray);
    free(barray);
    free(carray);
    free(darray);
    printf("\n");
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

struct AVLnode
{
    int key;
    struct AVLnode *left;
    struct AVLnode *right;
    int height;
};
typedef struct AVLnode avlNode;

int max(int a, int b) { return (a > b) ? a : b; }

avlNode *newNode(int key)
{
    avlNode *node = (avlNode *)malloc(sizeof(avlNode));

    if (node == NULL)
        printf("!! Out of Space !!\n");
    else
    {
        node->key = key;
        node->left = NULL;
        node->right = NULL;
        node->height = 0;
    }

    return node;
}

int nodeHeight(avlNode *node)
{
    if (node == NULL)
        return -1;
    else
        return (node->height);
}

int heightDiff(avlNode *node)
{
    if (node == NULL)
        return 0;
    else
        return (nodeHeight(node->left) - nodeHeight(node->right));
}


avlNode *minNode(avlNode *node)
{
    avlNode *temp = node;

    while (temp->left != NULL) temp = temp->left;

    return temp;
}

void printAVL(avlNode *node, int level)
{
    int i;
    if (node != NULL)
    {
        printAVL(node->right, level + 1);
        printf("\n\n");

        for (i = 0; i < level; i++) printf("\t");

        printf("%d", node->key);

        printAVL(node->left, level + 1);
    }
}

avlNode *rightRotate(avlNode *z)
{
    avlNode *y = z->left;
    avlNode *T3 = y->right;

    y->right = z;
    z->left = T3;

    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);
    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);

    return y;
}

avlNode *leftRotate(avlNode *z)
{
    avlNode *y = z->right;
    avlNode *T3 = y->left;

    y->left = z;
    z->right = T3;

    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);
    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);

    return y;
}

avlNode *LeftRightRotate(avlNode *z)
{
    z->left = leftRotate(z->left);

    return (rightRotate(z));
}

avlNode *RightLeftRotate(avlNode *z)
{
    z->right = rightRotate(z->right);

    return (leftRotate(z));
}

avlNode *insert(avlNode *node, int key)
{
    if (node == NULL)
        return (newNode(key));

    

    if (key < node->key)
        node->left =
            insert(node->left, key); 
    else if (key > node->key)
        node->right =
            insert(node->right, key); 

    
    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);

    
    int balance = heightDiff(node);

    
    if (balance > 1 && key < (node->left->key))
        return rightRotate(node);

    
    if (balance < -1 && key > (node->right->key))
        return leftRotate(node);

    
    if (balance > 1 && key > (node->left->key))
    {
        node = LeftRightRotate(node);
    }

    
    if (balance < -1 && key < (node->right->key))
    {
        node = RightLeftRotate(node);
    }

    return node;
}

avlNode *delete (avlNode *node, int queryNum)
{
    if (node == NULL)
        return node;

    if (queryNum < node->key)
        node->left =
            delete (node->left, queryNum); 
    else if (queryNum > node->key)
        node->right =
            delete (node->right, queryNum); 
    else
    {
        
        if ((node->left == NULL) || (node->right == NULL))
        {
            avlNode *temp = node->left ? node->left : node->right;

            
            if (temp == NULL)
            {
                temp = node;
                node = NULL;
            }
            else 
                *node = *temp;

            free(temp);
        }
        else
        {
            

            
            avlNode *temp = minNode(node->right);
            node->key = temp->key; 
            node->right =
                delete (node->right,
                        temp->key); 
        }
    }

    
    if (node == NULL)
        return node;

    
    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);

    int balance = heightDiff(node);

    
    if ((balance > 1) && (heightDiff(node->left) >= 0))
        return rightRotate(node);

    
    if ((balance > 1) && (heightDiff(node->left) < 0))
    {
        node = LeftRightRotate(node);
    }

    
    if ((balance < -1) && (heightDiff(node->right) >= 0))
        return leftRotate(node);

    
    if ((balance < -1) && (heightDiff(node->right) < 0))
    {
        node = RightLeftRotate(node);
    }

    return node;
}

avlNode *findNode(avlNode *node, int queryNum)
{
    if (node != NULL)
    {
        if (queryNum < node->key)
            node = findNode(node->left, queryNum);
        else if (queryNum > node->key)
            node = findNode(node->right, queryNum);
    }

    return node;
}

void printPreOrder(avlNode *node)
{
    if (node == NULL)
        return;

    printf("  %d  ", (node->key));
    printPreOrder(node->left);
    printPreOrder(node->right);
}

void printInOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printInOrder(node->left);
    printf("  %d  ", (node->key));
    printInOrder(node->right);
}

void printPostOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printPostOrder(node->left);
    printPostOrder(node->right);
    printf("  %d  ", (node->key));
}

int main()
{
    int choice;
    int flag = 1;
    int insertNum;
    int queryNum;

    avlNode *root = NULL;
    avlNode *tempNode;

    while (flag == 1)
    {
        printf("\n\nEnter the Step to Run : \n");

        printf("\t1: Insert a node into AVL tree\n");
        printf("\t2: Delete a node in AVL tree\n");
        printf("\t3: Search a node into AVL tree\n");
        printf("\t4: printPreOrder (Ro L R) Tree\n");
        printf("\t5: printInOrder (L Ro R) Tree\n");
        printf("\t6: printPostOrder (L R Ro) Tree\n");
        printf("\t7: printAVL Tree\n");

        printf("\t0: EXIT\n");
        scanf("%d", &choice);

        switch (choice)
        {
        case 0:
        {
            flag = 0;
            printf("\n\t\tExiting, Thank You !!\n");
            break;
        }

        case 1:
        {
            printf("\n\tEnter the Number to insert: ");
            scanf("%d", &insertNum);

            tempNode = findNode(root, insertNum);

            if (tempNode != NULL)
                printf("\n\t %d Already exists in the tree\n", insertNum);
            else
            {
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");

                root = insert(root, insertNum);
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 2:
        {
            printf("\n\tEnter the Number to Delete: ");
            scanf("%d", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf("\n\t %d Does not exist in the tree\n", queryNum);
            else
            {
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
                root = delete (root, queryNum);

                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 3:
        {
            printf("\n\tEnter the Number to Search: ");
            scanf("%d", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf("\n\t %d : Not Found\n", queryNum);
            else
            {
                printf("\n\t %d : Found at height %d \n", queryNum,
                       tempNode->height);

                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 4:
        {
            printf("\nPrinting Tree preOrder\n");
            printPreOrder(root);

            break;
        }

        case 5:
        {
            printf("\nPrinting Tree inOrder\n");
            printInOrder(root);

            break;
        }

        case 6:
        {
            printf("\nPrinting Tree PostOrder\n");
            printPostOrder(root);

            break;
        }

        case 7:
        {
            printf("\nPrinting AVL Tree\n");
            printAVL(root, 1);

            break;
        }

        default:
        {
            flag = 0;
            printf("\n\t\tExiting, Thank You !!\n");
            break;
        }
        }
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>



typedef struct node
{
        struct node *left;

        struct node *right;

        int data;
} node;

node *newNode(int data)
{
        node *tmp = (node *)malloc(sizeof(node));

        tmp->data = data;
    tmp->left = NULL;
    tmp->right = NULL;

    return tmp;
}

node *insert(node *root, int data)
{
        if (root == NULL)
        root = newNode(data);
            else if (data > root->data)
        root->right = insert(root->right, data);
            else if (data < root->data)
        root->left = insert(root->left, data);
        return root;
}

node *getMax(node *root)
{
        if (root->right == NULL)
        return root;
    else
        root->right = getMax(root->right);
}

node *delete (node *root, int data)
{
        if (root == NULL)
        return root;
        else if (data > root->data)
        root->right = delete (root->right, data);
        else if (data < root->data)
        root->left = delete (root->left, data);
            else if (data == root->data)
    {
                if ((root->left == NULL) && (root->right == NULL))
        {
            free(root);
            return NULL;
        }
                        else if (root->left == NULL)
        {
            node *tmp = root;
            root = root->right;
            free(tmp);
            return root;
        }
        else if (root->right == NULL)
        {
            node *tmp = root;
            root = root->left;
            free(tmp);
            return root;
        }
                        else
        {
                        node *tmp = getMax(root->left);

                                    root->data = tmp->data;
            root->left = delete (root->left, tmp->data);
        }
    }
    return root;
}

int find(node *root, int data)
{
        if (root == NULL)
        return 0;
        else if (data > root->data)
        return find(root->right, data);
        else if (data < root->data)
        return find(root->left, data);
        else if (data == root->data)
        return 1;
}

int height(node *root)
{
        if (root == NULL)
        return 0;
    else
    {
                        int right_h = height(root->right);
        int left_h = height(root->left);

                        if (right_h > left_h)
            return (right_h + 1);
        else
            return (left_h + 1);
    }
}

void purge(node *root)
{
    if (root != NULL)
    {
        if (root->left != NULL)
            purge(root->left);
        if (root->right != NULL)
            purge(root->right);
        free(root);
    }
}

void inOrder(node *root)
{
    if (root != NULL)
    {
        inOrder(root->left);
        printf("\t[ %d ]\t", root->data);
        inOrder(root->right);
    }
}

void main()
{
            node *root = NULL;
    int opt = -1;
    int data = 0;

        while (opt != 0)
    {
        printf(
            "\n\n[1] Insert Node\n[2] Delete Node\n[3] Find a Node\n[4] Get "
            "current Height\n[5] Print Tree in Crescent Order\n[0] Quit\n");
        scanf("%d", &opt);  
                switch (opt)
        {
        case 1:
            printf("Enter the new node's value:\n");
            scanf("%d", &data);
            root = insert(root, data);
            break;

        case 2:
            printf("Enter the value to be removed:\n");
            if (root != NULL)
            {
                scanf("%d", &data);
                root = delete (root, data);
            }
            else
                printf("Tree is already empty!\n");
            break;

        case 3:
            printf("Enter the searched value:\n");
            scanf("%d", &data);
            find(root, data) ? printf("The value is in the tree.\n")
                             : printf("The value is not in the tree.\n");
            break;

        case 4:
            printf("Current height of the tree is: %d\n", height(root));
            break;

        case 5:
            inOrder(root);
            break;
        }
    }

        purge(root);
}


#include <stdio.h>
#include <stdlib.h>

struct node
{
    struct node *leftNode;
    int data;
    struct node *rightNode;
};

struct node *newNode(int data)
{
    struct node *node = (struct node *)malloc(sizeof(struct node));

    node->leftNode = NULL;
    node->data = data;
    node->rightNode = NULL;

    return node;
}

int main(void)
{
    

    return 0;
}

#include <stdio.h>

void inOrderTraversal(struct node *node)
{
    if (node == NULL)          return;

    inOrderTraversal(node->leftNode);
    printf("\t%d\t", node->data);
    inOrderTraversal(node->rightNode);
}

void preOrderTraversal(struct node *node)
{
    if (node == NULL)          return;

    printf("\t%d\t", node->data);
    preOrderTraversal(node->leftNode);
    preOrderTraversal(node->rightNode);
}

void postOrderTraversal(struct node *node)
{
    if (node == NULL)          return;

    postOrderTraversal(node->leftNode);
    postOrderTraversal(node->rightNode);
    printf("\t%d\t", node->data);
}

int main(void)
{
    

    return 0;
}#include <math.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int val;
    struct node *par;
    struct node *left;
    struct node *right;
    int color;
} Node;

Node *newNode(int val, Node *par)
{
    Node *create = (Node *)(malloc(sizeof(Node)));
    create->val = val;
    create->par = par;
    create->left = NULL;
    create->right = NULL;
    create->color = 1;
}

int isLeaf(Node *n)
{
    if (n->left == NULL && n->right == NULL)
    {
        return 1;
    }
    return 0;
}

Node *leftRotate(Node *node)
{
    Node *parent = node->par;
    Node *grandParent = parent->par;

    parent->right = node->left;
    if (node->left != NULL)
    {
        node->left->par = parent;
    }
    node->par = grandParent;
    parent->par = node;
    node->left = parent;
    if (grandParent != NULL)
    {
        if (grandParent->right == parent)
        {
            grandParent->right = node;
        }
        else
        {
            grandParent->left = node;
        }
    }
    return node;
}

Node *rightRotate(Node *node)
{
    Node *parent = node->par;
    Node *grandParent = parent->par;

    parent->left = node->right;
    if (node->right != NULL)
    {
        node->right->par = parent;
    }
    node->par = grandParent;
    parent->par = node;
    node->right = parent;
    if (grandParent != NULL)
    {
        if (grandParent->right == parent)
        {
            grandParent->right = node;
        }
        else
        {
            grandParent->left = node;
        }
    }
    return node;
}

void checkNode(Node *node)
{
        if (node == NULL || node->par == NULL)
    {
        return;
    }
    Node *child = node;
        if (node->color == 0 || (node->par)->color == 0)
    {
                return;
    }

            Node *parent = node->par;
    Node *grandParent = parent->par;

            if (grandParent == NULL)
    {
        parent->color = 0;
        return;
    }

        if (grandParent->right != NULL && (grandParent->right)->color == 1 &&
        grandParent->left != NULL && (grandParent->left)->color == 1)
    {
                (grandParent->right)->color = 0;
        (grandParent->left)->color = 0;
        grandParent->color = 1;
        return;
    }
    else
    {
                Node *greatGrandParent = grandParent->par;
                if (grandParent->right == parent)
        {
                        if (parent->right == node)
            {
                grandParent->right = parent->left;
                if (parent->left != NULL)
                {
                    (parent->left)->par = grandParent;
                }
                parent->left = grandParent;
                grandParent->par = parent;

                                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {                                  parent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = parent;
                }
                child->right = parent;
                parent->par = child;

                                grandParent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = grandParent;
                }
                child->left = grandParent;
                grandParent->par = child;

                                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                                child->color = 0;
                grandParent->color = 1;
            }
        }
        else
        {                          if (parent->left == node)
            {
                grandParent->left = parent->right;
                if (parent->right != NULL)
                {
                    (parent->right)->par = grandParent;
                }
                parent->right = grandParent;
                grandParent->par = parent;

                                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {  
                                parent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = parent;
                }
                child->left = parent;
                parent->par = child;

                                grandParent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = grandParent;
                }
                child->right = grandParent;
                grandParent->par = child;

                                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                                child->color = 0;
                grandParent->color = 1;
            }
        }
    }
}

void insertNode(int val, Node **root)
{
    Node *buffRoot = *root;
    while (buffRoot)
    {
        if (buffRoot->val > val)
        {
                        if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                                Node *toInsert = newNode(val, buffRoot);
                buffRoot->left = toInsert;
                buffRoot = toInsert;

                                break;
            }
        }
        else
        {
                        if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                                Node *toInsert = newNode(val, buffRoot);
                buffRoot->right = toInsert;
                buffRoot = toInsert;

                                break;
            }
        }
    }

    while (buffRoot != *root)
    {
        checkNode(buffRoot);
        if (buffRoot->par == NULL)
        {
            *root = buffRoot;
            break;
        }
        buffRoot = buffRoot->par;
        if (buffRoot == *root)
        {
            buffRoot->color = 0;
        }
    }
}

void checkForCase2(Node *toDelete, int delete, int fromDirection, Node **root)
{
    if (toDelete == (*root))
    {
        (*root)->color = 0;
        return;
    }

    if (!delete &&toDelete->color == 1)
    {
        if (!fromDirection)
        {
            if (toDelete->right != NULL)
            {
                toDelete->right->color = 1;
            }
        }
        else
        {
            if (toDelete->left != NULL)
            {
                toDelete->left->color = 1;
            }
        }
        toDelete->color = 0;
        return;
    }

        Node *sibling;
    Node *parent = toDelete->par;
    int locateChild = 0;      if (parent->right == toDelete)
    {
        sibling = parent->left;
        locateChild = 1;
    }
    else
    {
        sibling = parent->right;
    }

        if ((sibling->right != NULL && sibling->right->color == 1) ||
        (sibling->left != NULL && sibling->left->color == 1))
    {
        if (sibling->right != NULL && sibling->right->color == 1)
        {
                        if (locateChild == 1)
            {
                int parColor = parent->color;

                                sibling = leftRotate(sibling->right);

                                parent = rightRotate(sibling);

                                if (parent->par == NULL)
                {
                    *root = parent;
                }

                                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
            else
            {                 
                int parColor = parent->color;

                                parent = leftRotate(sibling);

                                if (parent->par == NULL)
                {
                    *root = parent;
                }

                                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->left;
                    free(toDelete);
                }
            }
        }
        else
        {
                        if (locateChild == 0)
            {
                int parColor = parent->color;

                                sibling = rightRotate(sibling->left);

                                
                                parent = leftRotate(sibling);

                                if (parent->par == NULL)
                {
                    *root = parent;
                }

                                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->right;
                    free(toDelete);
                }
            }
            else
            {                 
                int parColor = parent->color;

                                parent = rightRotate(sibling);

                                if (parent->par == NULL)
                {
                    *root = parent;
                }

                                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
        }
    }
    else if (sibling->color == 0)
    {  
                sibling->color = 1;

                if (delete)
        {
            if (locateChild)
            {
                toDelete->par->right = toDelete->left;
                if (toDelete->left != NULL)
                {
                    toDelete->left->par = toDelete->par;
                }
            }
            else
            {
                toDelete->par->left = toDelete->right;
                if (toDelete->right != NULL)
                {
                    toDelete->right->par = toDelete->par;
                }
            }
        }

        checkForCase2(parent, 0, locateChild, root);
    }
    else
    {          if (locateChild)
        {  
            toDelete->par->right = toDelete->left;
            if (toDelete->left != NULL)
            {
                toDelete->left->par = toDelete->par;
            }

            parent = rightRotate(sibling);

                        if (parent->par == NULL)
            {
                *root = parent;
            }

            parent->color = 0;
            parent->right->color = 1;
            checkForCase2(parent->right, 0, 1, root);
        }
        else
        {  
            toDelete->par->left = toDelete->right;
            if (toDelete->right != NULL)
            {
                toDelete->right->par = toDelete->par;
            }
            parent = leftRotate(sibling);

                        if (parent->par == NULL)
            {
                *root = parent;
            }

            printf("\nroot - %d - %d\n", parent->val, parent->left->val);

            parent->color = 0;
            parent->left->color = 1;
            checkForCase2(parent->left, 0, 0, root);
        }
    }
}

void deleteNode(int val, Node **root)
{
    Node *buffRoot = *root;

        while (1)
    {
        if (val == buffRoot->val)
        {
                        break;
        }

        if (val > buffRoot->val)
        {
            if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                printf("Node Not Found!!!");
                return;
            }
        }
        else
        {
            if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                printf("Node Not Found!!!");
                return;
            }
        }
    }

    Node *toDelete = buffRoot;

        if (toDelete->left != NULL)
    {
        toDelete = toDelete->left;
        while (toDelete->right != NULL)
        {
            toDelete = toDelete->right;
        }
    }
    else if (toDelete->right != NULL)
    {
        toDelete = toDelete->right;
        while (toDelete->left != NULL)
        {
            toDelete = toDelete->left;
        }
    }

    if (toDelete == *root)
    {
        *root = NULL;
        return;
    }

        buffRoot->val = toDelete->val;
    toDelete->val = val;

        if (toDelete->color == 1 ||
        (toDelete->left != NULL && toDelete->left->color == 1) ||
        (toDelete->right != NULL && toDelete->right->color == 1))
    {
                if (toDelete->left == NULL && toDelete->right == NULL)
        {
                        if (toDelete->par->left == toDelete)
            {
                toDelete->par->left = NULL;
            }
            else
            {
                toDelete->par->right = NULL;
            }
        }
        else
        {  
                        if (toDelete->left != NULL)
            {
                                toDelete->par->right = toDelete->left;
                toDelete->left->par = toDelete->par;
                toDelete->left->color = 1;
            }
            else
            {                  toDelete->par->left = toDelete->right;
                toDelete->right->par = toDelete->par;
                toDelete->right->color = 1;
            }
        }

                free(toDelete);
    }
    else
    {          checkForCase2(toDelete, 1, ((toDelete->par->right == toDelete)), root);
    }
}

void printInorder(Node *root)
{
    if (root != NULL)
    {
        printInorder(root->left);
        printf("%d c-%d ", root->val, root->color);
        printInorder(root->right);
    }
}

void checkBlack(Node *temp, int c)
{
    if (temp == NULL)
    {
        printf("%d ", c);
        return;
    }
    if (temp->color == 0)
    {
        c++;
    }
    checkBlack(temp->left, c);
    checkBlack(temp->right, c);
}

int main()
{
    Node *root = NULL;
    int scanValue, choice = 1;
    printf(
        "1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - Quit\n\nPlease "
        "Enter the Choice - ");
    scanf("%d", &choice);
    while (choice)
    {
        switch (choice)
        {
        case 1:
            printf("\n\nPlease Enter A Value to insert - ");
            scanf("%d", &scanValue);
            if (root == NULL)
            {
                root = newNode(scanValue, NULL);
                root->color = 0;
            }
            else
            {
                insertNode(scanValue, &root);
            }
            printf("\nSuccessfully Inserted %d in the tree\n\n", scanValue);
            break;
        case 2:
            printf("\n\nPlease Enter A Value to Delete - ");
            scanf("%d", &scanValue);
            deleteNode(scanValue, &root);
            printf("\nSuccessfully Inserted %d in the tree\n\n", scanValue);
            break;
        case 3:
            printf("\nInorder Traversel - ");
            printInorder(root);
            printf("\n\n");
                                    break;
        default:
            if (root != NULL)
            {
                printf("Root - %d\n", root->val);
            }
        }
        printf(
            "1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - "
            "Quit\n\nPlease Enter the Choice - ");
        scanf("%d", &choice);
    }
}



#include <stdio.h>
#include <stdlib.h>


typedef struct Node
{
    int data;           
    struct Node *llink; 
    struct Node *rlink; 
} node;


node *create_node(int data)
{
    node *ptr = (node *)malloc(sizeof(node));
    ptr->rlink = ptr->llink = NULL;
    ptr->data = data;
    return ptr;
}


void insert_bt(node **root, int data)
{
    node *new_node = create_node(data);
    node *temp;      node *prev;      if (*root == NULL)
    {
        *root = new_node;
    }
    else
    {
        temp = *root;
        prev = NULL;
        while (temp != NULL)
        {
            if (new_node->data > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else if (new_node->data < temp->data)
            {
                prev = temp;
                temp = temp->llink;
            }
            else
            {
                return;
            }
        }

        if (new_node->data > prev->data)
        {
            prev->rlink = new_node;
        }
        else
        {
            prev->llink = new_node;
        }
    }
}


void search(node *root, int ele)
{
    node *temp = root;
    while (temp != NULL)
    {
        if (temp->data == ele)
        {
            break;
        }
        else if (ele > temp->data)
        {
            temp = temp->rlink;
        }
        else
        {
            temp = temp->llink;
        }
    }

    if (temp == NULL)
    {
        printf("%s\n", "Element not found.");
    }
    else
        printf("%s\n", "Element found.");
}


void inorder_display(node *curr)
{
    if (curr != NULL)
    {
        inorder_display(curr->llink);
        printf("%d\t", curr->data);
        inorder_display(curr->rlink);
    }
}


void postorder_display(node *curr)
{
    if (curr != NULL)
    {
        postorder_display(curr->llink);
        postorder_display(curr->rlink);
        printf("%d\t", curr->data);
    }
}


void preorder_display(node *curr)
{
    if (curr != NULL)
    {
        printf("%d\t", curr->data);
        preorder_display(curr->llink);
        preorder_display(curr->rlink);
    }
}


void delete_bt(node **root, int ele)
{
    node *temp;
    node *prev;
    if (*root == NULL)
        return;
    else
    {
        temp = *root;
        prev = NULL;
                while (temp != NULL)
        {
            if (temp->data == ele)
            {
                break;
            }
            else if (ele > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else
            {
                prev = temp;
                temp = temp->llink;
            }
        }
    }

    if (temp == NULL)
        return;
    else
    {
        node *replacement;          node *t;
        if (temp->llink == NULL && temp->rlink == NULL)
        {
            replacement = NULL;
        }
        else if (temp->llink == NULL && temp->rlink != NULL)
        {
            replacement = temp->rlink;
        }
        else if (temp->llink != NULL && temp->rlink == NULL)
        {
            replacement = temp->llink;
        }
        else
        {
            replacement = temp->rlink;              t = replacement;
            while (t->llink != NULL)
            {
                t = t->llink;
            }
            t->llink =
                temp->llink;                                        }

        if (temp == *root)
        {
            free(*root);
            *root = replacement;
        }
        else if (prev->llink == temp)
        {
            free(prev->llink);
            prev->llink = replacement;
        }
        else if (prev->rlink == temp)
        {
            free(prev->rlink);
            prev->rlink = replacement;
        }
    }
}


int main()
{
    printf("BINARY THREADED TREE: \n");
    node *root = NULL;
    int choice, n;
    do
    {
        printf("%s\n", "1. Insert into BT");
        printf("%s\n", "2. Print BT - inorder");
        printf("%s\n", "3. Print BT - preorder");
        printf("%s\n", "4. print BT - postorder");
        printf("%s\n", "5. delete from BT");
        printf("%s\n", "6. search in BT");
        printf("%s\n", "Type 0 to exit");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            insert_bt(&root, n);
            break;
        case 2:
            inorder_display(root);
            printf("\n");
            break;
        case 3:
            preorder_display(root);
            printf("\n");
            break;
        case 4:
            postorder_display(root);
            printf("\n");
            break;
        case 5:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            delete_bt(&root, n);
            break;
        case 6:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            search(root, n);
            break;
        }
    } while (choice != 0);
    return 0;
}
#include "dict.h"
#include <stdio.h>
#include <stdlib.h>


Dictionary *create_dict(void)
{
    Dictionary *p_dic = malloc(sizeof(Dictionary));
    if (p_dic)
    {
        p_dic->number_of_elements = 0;

        
        for (int i = 0; i < MAXELEMENTS; i++)
        {
            p_dic->elements[i] = NULL;
        }

        return p_dic;
    }
    else
    {
        printf("unable to create a dictionary\n");
        return NULL;
    }
}


int get_hash(char s[])
{
    unsigned int hash_code = 0;

    
    for (int counter = 0; s[counter] != '\0'; counter++)
    {
        
        hash_code =
            s[counter] + (hash_code << 6) + (hash_code << 16) - hash_code;
    }

    
    return hash_code % MAXELEMENTS;
}

int add_item_label(Dictionary *dic, char label[], void *item)
{
    unsigned int index = get_hash(label);

    
    if (index < MAXELEMENTS)
    {
        dic->elements[index] = item;
        return 0;
    }

    
    return -1;
}

int add_item_index(Dictionary *dic, int index, void *item)
{
    
    if (!dic->elements[index])
    {
        dic->elements[index] = item;
        return 0;
    }

    
    return -1;
}

void *get_element_label(Dictionary *dict, char s[])
{
    int index = get_hash(s);
    if (dict->elements[index])
    {
        return dict->elements[index];
    }

    printf("None entry at given label\n");
    return NULL;
}

void *get_element_index(Dictionary *dict, int index)
{
    if (index >= 0 && index < MAXELEMENTS)
    {
        return dict->elements[index];
    }

    printf("index out of bounds!\n");
    return NULL;
}

void destroy(Dictionary *dict) { free(dict); }

#include <stdio.h>


#include "dict.h"

int main(void)
{
    Dictionary *testObj1;
    Dictionary *testObj2;

    int value = 28;

    testObj1 = create_dict();
    testObj2 = create_dict();

    add_item_label(testObj1, "age", &value);
    add_item_label(testObj2, "name", "Christian");

    
    printf("My age is %d\n", *((int *)get_element_label(testObj1, "age")));
    printf("My name is %s\n", get_element_label(testObj2, "name"));

    
    if (!add_item_index(testObj1, 0, &value))
    {
        printf("My age at index %d is %d\n", 0,
               *((int *)get_element_index(testObj1, 0)));
    }

    
    

    
    destroy(testObj1);
    destroy(testObj2);

    return 0;
}#include "dynamic_array.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

dynamic_array_t *init_dynamic_array()
{
    dynamic_array_t *da = malloc(sizeof(dynamic_array_t));
    da->items = calloc(DEFAULT_CAPACITY, sizeof(void *));
    da->capacity = DEFAULT_CAPACITY;

    return da;
}

void *add(dynamic_array_t *da, const void *value)
{
    if (da->size >= da->capacity)
    {
        void **newItems =
            realloc(da->items, (da->capacity <<= 1) * sizeof(void **));
        free(da->items);

        da->items = newItems;
    }

    void *copy_value = retrive_copy_of_value(value);
    da->items[da->size++] = copy_value;

    return copy_value;
}

void *put(dynamic_array_t *da, const void *value, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    free(da->items[index]);
    void *copy_value = retrive_copy_of_value(value);
    da->items[index] = copy_value;

    return copy_value;
}

void *get(dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    return da->items[index];
}

void delete (dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return;

    for (unsigned i = index; i < da->size; i++)
    {
        da->items[i] = da->items[i + 1];
    }

    da->size--;

    free(da->items[da->size]);
}

unsigned contains(const unsigned size, const unsigned index)
{
    if (size >= 0 && index < size)
        return 1;

    printf("index [%d] out of bounds!\n", index);
    return 0;
}

void *retrive_copy_of_value(const void *value)
{
    void *value_copy = malloc(sizeof(void *));
    memcpy(value_copy, value, sizeof(void *));

    return value_copy;
}#include <stdio.h>
#include <stdlib.h>
#include "dynamic_array.h"

int main()
{
    dynamic_array_t *da = init_dynamic_array();

    for (int i = 1; i <= 50; i++)
    {
        add(da, &i);
    }

    delete (da, 10);

    int value = 1000;

    put(da, &value, 0);

    value = 5000;

    int another_value = 7000;

    add(da, &another_value);

    for (int i = 0; i < da->size; i++)
    {
        printf("value %d\n", *(int *)get(da, i));
    }

    int value_for_invalid_index = 10000;

    put(da, &value_for_invalid_index, 150);
    return 0;
}#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Edge
{
    int src, dst, weight;
};

struct Graph
{
    int vertexNum;
    int edgeNum;
    struct Edge *edges;
};

void createGraph(struct Graph *G, int V, int E)
{
    G->vertexNum = V;
    G->edgeNum = E;
    G->edges = (struct Edge *)malloc(E * sizeof(struct Edge));
}

void addEdge(struct Graph *G, int src, int dst, int weight)
{
    static int ind;
    struct Edge newEdge;
    newEdge.src = src;
    newEdge.dst = dst;
    newEdge.weight = weight;
    G->edges[ind++] = newEdge;
}

int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX, minInd;
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}

void print(int dist[], int V)
{
    printf("\nVertex  Distance\n");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf("%d\t%d\n", i, dist[i]);
        else
            printf("%d\tINF", i);
    }
}

void BellmanFord(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int E = graph->edgeNum;
    int dist[V];

            for (int i = 0; i < V; i++) dist[i] = INT_MAX;
    dist[src] = 0;

            for (int i = 0; i <= V - 1; i++)
        for (int j = 0; j < E; j++)
        {
            int u = graph->edges[j].src;
            int v = graph->edges[j].dst;
            int w = graph->edges[j].weight;

            if (dist[u] != INT_MAX && dist[u] + w < dist[v])
                dist[v] = dist[u] + w;
        }

        for (int j = 0; j < E; j++)
    {
        int u = graph->edges[j].src;
        int v = graph->edges[j].dst;
        int w = graph->edges[j].weight;

        if (dist[u] != INT_MAX && dist[u] + w < dist[v])
        {
            printf(
                "Graph contains negative weight cycle. Hence, shortest "
                "distance not guaranteed.");
            return;
        }
    }

    print(dist, V);

    return;
}

int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V, E);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf("\nEnter source:");
    scanf("%d", &gsrc);
    BellmanFord(&G, gsrc);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define SIZE 40
struct queue
{
    int items[SIZE];
    int front;
    int rear;
};

struct queue *createQueue();
void enqueue(struct queue *q, int);
int dequeue(struct queue *q);
void display(struct queue *q);
int isEmpty(struct queue *q);
int pollQueue(struct queue *q);

struct node
{
    int vertex;
    struct node *next;
};

struct node *createNode(int);

struct Graph
{
    int numVertices;
    struct node **adjLists;
    int *visited;
};
struct Graph *createGraph(int vertices);
void addEdge(struct Graph *graph, int src, int dest);
void printGraph(struct Graph *graph);
void bfs(struct Graph *graph, int startVertex);

int main()
{
    int vertices, edges, source, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("Enter source of bfs\n");
    scanf("%d", &source);
    bfs(graph, source);

        

    return 0;
}
void bfs(struct Graph *graph, int startVertex)
{
    struct queue *q = createQueue();

        graph->visited[startVertex] = 1;
    enqueue(q, startVertex);
    printf("Breadth first traversal from vertex %d is:\n", startVertex);

        while (!isEmpty(q))
    {
        printf("%d ", pollQueue(q));
        int currentVertex = dequeue(q);

        struct node *temp = graph->adjLists[currentVertex];
                        while (temp)
        {
            int adjVertex = temp->vertex;
                        if (graph->visited[adjVertex] == 0)
            {
                graph->visited[adjVertex] = 1;
                enqueue(q, adjVertex);
            }
            temp = temp->next;
        }
    }
}
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }

    return graph;
}
void addEdge(struct Graph *graph, int src, int dest)
{
        struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

        newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}
struct queue *createQueue()
{
    struct queue *q = malloc(sizeof(struct queue));
    q->front = -1;
    q->rear = -1;
    return q;
}
int isEmpty(struct queue *q)
{
    if (q->rear == -1)
        return 1;
    else
        return 0;
}
void enqueue(struct queue *q, int value)
{
    if (q->rear == SIZE - 1)
        printf("\nQueue is Full!!");
    else
    {
        if (q->front == -1)
            q->front = 0;
        q->rear++;
        q->items[q->rear] = value;
    }
}
int dequeue(struct queue *q)
{
    int item;
    if (isEmpty(q))
    {
        printf("Queue is empty");
        item = -1;
    }
    else
    {
        item = q->items[q->front];
        q->front++;
        if (q->front > q->rear)
        {
            q->front = q->rear = -1;
        }
    }
    return item;
}

int pollQueue(struct queue *q) { return q->items[q->front]; }
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"
#include "queue.h"

#define MAX_NODES 1000

int visited[MAX_NODES];                           
bool findPathBFS(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = -1;

    visited[src] = src;
    queue Q = newQueue();
    QueueEnqueue(Q, src);
    while (!QueueIsEmpty(Q))
    {
        v = QueueDequeue(Q);
        Vertex w;
        for (w = 0; w < nV; w++)
            if (adjacent(g, v, w) && visited[w] == -1)
            {
                visited[w] = v;
                if (w == dest)
                    return true;
                else
                    QueueEnqueue(Q, w);
            }
    }
    return false;
}

int main(void)
{
    int V = 10;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 2;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 1;
    e.w = 5;
    insertEdge(g, e);
    e.v = 2;
    e.w = 3;
    insertEdge(g, e);
    e.v = 3;
    e.w = 4;
    insertEdge(g, e);
    e.v = 3;
    e.w = 5;
    insertEdge(g, e);
    e.v = 3;
    e.w = 8;
    insertEdge(g, e);
    e.v = 4;
    e.w = 5;
    insertEdge(g, e);
    e.v = 4;
    e.w = 7;
    insertEdge(g, e);
    e.v = 4;
    e.w = 8;
    insertEdge(g, e);
    e.v = 5;
    e.w = 6;
    insertEdge(g, e);
    e.v = 7;
    e.w = 8;
    insertEdge(g, e);
    e.v = 7;
    e.w = 9;
    insertEdge(g, e);
    e.v = 8;
    e.w = 9;
    insertEdge(g, e);

    int src = 0, dest = 6;
    if (findPathBFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf("%d - ", v);
            v = visited[v];
        }
        printf("%d\n", src);
    }
    return 0;
}


#include <stdio.h>
#include <stdlib.h>

struct node
{
    int vertex;
    struct node *next;
};
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;                      };
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
void dfs(struct Graph *, int);

int main()
{
    int vertices, edges, source, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("Enter source of DFS\n");
    scanf("%d", &source);
    printf("DFS from %d is:\n", source);
    dfs(graph, source);
    printf("\n");

        

    return 0;
}
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

        graph->visited[vertex] = 1;
    printf("%d ", vertex);

        while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));

    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
void addEdge(struct Graph *graph, int src, int dest)
{
        struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

        newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

#define MAX_NODES 1000

int visited[MAX_NODES];                           
bool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest)
{
    Vertex w;
    for (w = 0; w < nV; w++)
        if (adjacent(g, v, w) && visited[w] == -1)
        {
            visited[w] = v;
            if (w == dest)
                return true;
            else if (dfsPathCheck(g, nV, w, dest))
                return true;
        }
    return false;
}

bool findPathDFS(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = -1;
    visited[src] = src;
    return dfsPathCheck(g, nV, src, dest);
}

int main(void)
{
    int V = 6;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 4;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 5;
    e.w = 4;
    insertEdge(g, e);
    e.v = 4;
    e.w = 2;
    insertEdge(g, e);
    e.v = 4;
    e.w = 3;
    insertEdge(g, e);
    e.v = 5;
    e.w = 3;
    insertEdge(g, e);
    e.v = 1;
    e.w = 2;
    insertEdge(g, e);
    e.v = 3;
    e.w = 2;
    insertEdge(g, e);

    int src = 0, dest = 5;
    if (findPathDFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf("%d - ", v);
            v = visited[v];
        }
        printf("%d\n", src);
    }
    return 0;
}


#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Graph
{
    int vertexNum;
    int **edges;
};

void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}

void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}

int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX, minInd;
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}

void print(int dist[], int V)
{
    printf("\nVertex  Distance\n");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf("%d\t%d\n", i, dist[i]);
        else
            printf("%d\tINF", i);
    }
}

void Dijkstra(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int mdist[V];      int vset[V];                      
        for (int i = 0; i < V; i++) mdist[i] = INT_MAX, vset[i] = 0;

    mdist[src] = 0;

        for (int count = 0; count < V - 1; count++)
    {
        int u = minDistance(mdist, vset, V);
        vset[u] = 1;

        for (int v = 0; v < V; v++)
        {
            if (!vset[v] && graph->edges[u][v] != INT_MAX &&
                mdist[u] + graph->edges[u][v] < mdist[v])
                mdist[v] = mdist[u] + graph->edges[u][v];
        }
    }

    print(mdist, V);

    return;
}

int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf("\nEnter source:");
    scanf("%d", &gsrc);
    Dijkstra(&G, gsrc);

    return 0;
}
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

int degree(Graph g, int nV, Vertex v)
{
    int deg = 0;
    Vertex w;
    for (w = 0; w < nV; w++)
        if (adjacent(g, v, w))
            deg++;
    return deg;
}

bool hasEulerPath(Graph g, int nV, Vertex v, Vertex w)
{
    if (v != w)
    {
        if (degree(g, nV, v) % 2 == 0 || degree(g, nV, w) % 2 == 0)
            return false;
    }
    else if (degree(g, nV, v) % 2 != 0)
    {
        return false;
    }
    Vertex x;
    for (x = 0; x < nV; x++)
        if (x != v && x != w && degree(g, nV, x) % 2 != 0)
            return false;
    return true;
}

int main(void)
{
    Edge e;
    int n;

    printf("Enter the number of vertices: ");
    scanf("%d", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf("Enter source node: ");
    scanf("%d", &src);
    printf("Enter destination node: ");
    scanf("%d", &dest);

    printf("Enter an edge (from): ");
    while (scanf("%d", &e.v) == 1)
    {
        printf("Enter an edge (to): ");
        scanf("%d", &e.w);
        insertEdge(g, e);
        printf("Enter an edge (from): ");
    }
    printf("Finished.\n");

    printf("The graph has ");
    if (hasEulerPath(g, n, src, dest))
        printf("an");
    else
        printf("no");
    printf(" Euler path from %d to %d.\n", src, dest);

    freeGraph(g);
    return 0;
}


#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Graph
{
    int vertexNum;
    int **edges;
};

void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}

void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}

void print(int dist[], int V)
{
    printf("\nThe Distance matrix for Floyd - Warshall\n");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            if (dist[i * V + j] != INT_MAX)
                printf("%d\t", dist[i * V + j]);
            else
                printf("INF\t");
        }
        printf("\n");
    }
}

void FloydWarshall(struct Graph *graph)
{
    int V = graph->vertexNum;
    int dist[V][V];

        for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist[i][j] = graph->edges[i][j];

        for (int k = 0; k < V; k++)
        
        for (int i = 0; i < V; i++)
            
            for (int j = 0; j < V; j++)
                
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&
                    dist[i][k] + dist[k][j] < dist[i][j])
                                                            dist[i][j] = dist[i][k] + dist[k][j];

        int dist1d[V * V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];

    print(dist1d, V);
}

int main()
{
    int V, E;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    FloydWarshall(&G);

    return 0;
}
#include "Graph.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct GraphRep
{
    int **edges;      int nV;           int nE;       } GraphRep;

Graph newGraph(int V)
{
    assert(V >= 0);
    int i;

    Graph g = malloc(sizeof(GraphRep));
    assert(g != NULL);
    g->nV = V;
    g->nE = 0;

        g->edges = malloc(V * sizeof(int *));
    assert(g->edges != NULL);
        for (i = 0; i < V; i++)
    {
        g->edges[i] = calloc(V, sizeof(int));
        assert(g->edges[i] != NULL);
    }

    return g;
}

bool validV(Graph g, Vertex v) { return (g != NULL && v >= 0 && v < g->nV); }

void insertEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (!g->edges[e.v][e.w])
    {          g->edges[e.v][e.w] = 1;
        g->edges[e.w][e.v] = 1;
        g->nE++;
    }
}

void removeEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (g->edges[e.v][e.w])
    {          g->edges[e.v][e.w] = 0;
        g->edges[e.w][e.v] = 0;
        g->nE--;
    }
}

bool adjacent(Graph g, Vertex v, Vertex w)
{
    assert(g != NULL && validV(g, v) && validV(g, w));

    return (g->edges[v][w] != 0);
}

void showGraph(Graph g)
{
    assert(g != NULL);
    int i, j;

    printf("Number of vertices: %d\n", g->nV);
    printf("Number of edges: %d\n", g->nE);
    for (i = 0; i < g->nV; i++)
        for (j = i + 1; j < g->nV; j++)
            if (g->edges[i][j])
                printf("Edge %d - %d\n", i, j);
}

void freeGraph(Graph g)
{
    assert(g != NULL);

    int i;
    for (i = 0; i < g->nV; i++) free(g->edges[i]);
    free(g->edges);
    free(g);
}


#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

#define MAX_NODES 1000

bool visited[MAX_NODES];

bool hamiltonR(Graph g, int nV, Vertex v, Vertex dest, int d)
{
            
    Vertex w;
    if (v == dest)
    {
        return (d == 0);
    }
    else
    {
        visited[v] = true;
        for (w = 0; w < nV; w++)
        {
            if (adjacent(g, v, w) && !visited[w])
            {
                if (hamiltonR(g, nV, w, dest, d - 1))
                {
                    return true;
                }
            }
        }
    }
    visited[v] = false;
    return false;
}

bool hasHamiltonianPath(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = false;
    return hamiltonR(g, nV, src, dest, nV - 1);
}

int main(void)
{
    Edge e;
    int n;

    printf("Enter the number of vertices: ");
    scanf("%d", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf("Enter source node: ");
    scanf("%d", &src);
    printf("Enter destination node: ");
    scanf("%d", &dest);

    printf("Enter an edge (from): ");
    while (scanf("%d", &e.v) == 1)
    {
        printf("Enter an edge (to): ");
        scanf("%d", &e.w);
        insertEdge(g, e);
        printf("Enter an edge (from): ");
    }
    printf("Finished.\n");

    printf("The graph has ");
    if (hasHamiltonianPath(g, n, src, dest))
        printf("a");
    else
        printf("no");
    printf(" Hamiltonian path from %d to %d.\n", src, dest);

    freeGraph(g);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Edge
{
    int src, dest, weight;
};

struct Graph
{
        int V, E;

                    struct Edge *edge;
};

struct Graph *createGraph(int V, int E)
{
    struct Graph *graph = new Graph();
    graph->V = V;
    graph->E = E;

    graph->edge = new Edge[E];

    return graph;
}

struct subset
{
    int parent;
    int rank;
};

int find(struct subset subsets[], int i)
{
            if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);

    return subsets[i].parent;
}

void Union(struct subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

            if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;

            else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

int myComp(const void *a, const void *b)
{
    struct Edge *a1 = (struct Edge *)a;
    struct Edge *b1 = (struct Edge *)b;
    return a1->weight > b1->weight;
}

void KruskalMST(struct Graph *graph)
{
    int V = graph->V;
    struct Edge result[V];      int e = 0;                  int i = 0;              
                    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);

        struct subset *subsets = (struct subset *)malloc(V * sizeof(struct subset));

        for (int v = 0; v < V; ++v)
    {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

        while (e < V - 1 && i < graph->E)
    {
                        struct Edge next_edge = graph->edge[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

                                if (x != y)
        {
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
            }

            printf("Following are the edges in the constructed MST\n");
    for (i = 0; i < e; ++i)
        printf("%d -- %d == %d\n", result[i].src, result[i].dest,
               result[i].weight);
    return;
}

int main()
{
    
    int V = 4;      int E = 5;      struct Graph *graph = createGraph(V, E);

        graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = 10;

        graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 6;

        graph->edge[2].src = 0;
    graph->edge[2].dest = 3;
    graph->edge[2].weight = 5;

        graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 15;

        graph->edge[4].src = 2;
    graph->edge[4].dest = 3;
    graph->edge[4].weight = 4;

    KruskalMST(graph);

    return 0;
}

#include "queue.h"
#include <assert.h>
#include <stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
} NodeT;

typedef struct QueueRep
{
    int length;
    NodeT *head;
    NodeT *tail;
} QueueRep;

queue newQueue()
{
    queue Q = malloc(sizeof(QueueRep));
    Q->length = 0;
    Q->head = NULL;
    Q->tail = NULL;
    return Q;
}

void dropQueue(queue Q)
{
    NodeT *curr = Q->head;
    while (curr != NULL)
    {
        NodeT *temp = curr->next;
        free(curr);
        curr = temp;
    }
    free(Q);
}

int QueueIsEmpty(queue Q) { return (Q->length == 0); }

void QueueEnqueue(queue Q, int v)
{
    NodeT *new = malloc(sizeof(NodeT));
    assert(new != NULL);
    new->data = v;
    new->next = NULL;
    if (Q->tail != NULL)
    {
        Q->tail->next = new;
        Q->tail = new;
    }
    else
    {
        Q->head = new;
        Q->tail = new;
    }
    Q->length++;
}

int QueueDequeue(queue Q)
{
    assert(Q->length > 0);
    NodeT *p = Q->head;
    Q->head = Q->head->next;
    if (Q->head == NULL)
    {
        Q->tail = NULL;
    }
    Q->length--;
    int d = p->data;
    free(p);
    return d;
}


#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 40  #define INT_MIN 0
struct node
{
    int vertex;
    struct node *next;
};
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;                      };
struct Stack
{
    int arr[MAX_SIZE];
    int top;
};
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
struct Graph *transpose(struct Graph *);
void fillOrder(int, struct Graph *, struct Stack *);
void scc(struct Graph *);
void dfs(struct Graph *, int);
struct Stack *createStack();
void push(struct Stack *, int);
int pop(struct Stack *);

int main()
{
    int vertices, edges, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("The strongly connected conponents are:\n");
    scc(graph);
    printf("\n");

        
    return 0;
}
void fillOrder(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
        while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            fillOrder(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
        push(stack, vertex);
}
struct Graph *transpose(struct Graph *g)
{
    struct Graph *graph =
        createGraph(g->numVertices);      int i = 0;
    for (i = 0; i < g->numVertices; i++)
    {
        struct node *temp = g->adjLists[i];
        while (temp != NULL)
        {
            addEdge(graph, temp->vertex, i);              temp = temp->next;
        }
    }
    return graph;
}
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

        graph->visited[vertex] = 1;
    printf("%d ", vertex);

        while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}

void scc(struct Graph *graph)
{
        struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
                if (graph->visited[i] == 0)
        {
            fillOrder(i, graph, stack);
        }
    }
        struct Graph *graphT = transpose(graph);
        while (stack->top != -1)
    {
        int v = pop(stack);
        if (graphT->visited[v] == 0)
        {
            dfs(graphT, v);
            printf("\n");
        }
    }
}

struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
void addEdge(struct Graph *graph, int src, int dest)
{
        struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  }
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 40  #define INT_MIN 0
struct node
{
    int vertex;
    struct node *next;
};
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;                      };
struct Stack
{
    int arr[MAX_SIZE];
    int top;
};
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
void topologicalSortHelper(int, struct Graph *, struct Stack *);
void topologicalSort(struct Graph *);
struct Stack *createStack();
void push(struct Stack *, int);
int pop(struct Stack *);

int main()
{
    int vertices, edges, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("One topological sort order is:\n");
    topologicalSort(graph);
    printf("\n");

        
    return 0;
}

void topologicalSortHelper(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
        while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            topologicalSortHelper(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
        push(stack, vertex);
}

void topologicalSort(struct Graph *graph)
{
    struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
                if (graph->visited[i] == 0)
        {
            topologicalSortHelper(i, graph, stack);
        }
    }
    while (stack->top != -1) printf("%d ", pop(stack));
}
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
void addEdge(struct Graph *graph, int src, int dest)
{
        struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  }
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}
#include <stdbool.h>
#include <stdio.h>

#define NODES 4

int digraph[NODES][NODES] = {
    {0, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}};
int tc[NODES][NODES];

void warshall()
{
    int i, s, t;
    for (s = 0; s < NODES; s++)
        for (t = 0; t < NODES; t++) tc[s][t] = digraph[s][t];

    for (i = 0; i < NODES; i++)
        for (s = 0; s < NODES; s++)
            for (t = 0; t < NODES; t++)
                if (tc[s][i] && tc[i][t])
                    tc[s][t] = 1;
}

int main(void)
{
    warshall();
    int i, j;
    for (i = 0; i < NODES; i++)
    {
        for (j = 0; j < NODES; j++)
        {
            printf("%d ", tc[i][j]);
        }
        putchar('\n');
    }
    return 0;
}


#include <stdio.h>
#include <stdlib.h>

#include "hash_set.h"

extern hash_set_t *init_hash_set()
{
    hash_set_t *set = (hash_set_t *)malloc(sizeof(hash_set_t));
    set->keys = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->values = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->length = 0;
    set->capacity = DEFAULT_HASH_SET_CAPACITY;

    return set;
}

unsigned add(hash_set_t *set, void *value)
{
    return put(set, hash(value), value);
}

unsigned put(hash_set_t *set, long long hash, void *value)
{
    if (contains_hash(set, hash))
    {
        if (set->keys[retrieve_index_from_hash(hash, set->capacity)] == value)
        {
            return 0;
        }

                resize(set);

        return put(set, hash, value);
    }

    set->keys[retrieve_index_from_hash(hash, set->capacity)] = value;
    set->values[set->length++] = value;

    return 1;
}

int contains(hash_set_t *set, void *value)
{
    return set->keys[retrieve_index_from_hash(hash(value), set->capacity)] ==
                   value
               ? 1
               : 0;
}

int contains_hash(hash_set_t *set, long long hash)
{
    return set->keys[retrieve_index_from_hash(hash, set->capacity)] ? 1 : 0;
}

void delete (hash_set_t *set, void *value)
{
    set->keys[retrieve_index_from_hash(hash(value), set->capacity)] = NULL;
}

long long hash(void *value)
{
    char *str = value;

    int a = 1;
    int b = 0;
    const int MODADLER = 65521;

    for (int i = 0; str[i] != '\0'; i++)
    {
        a = (a + str[i]) % MODADLER;
        b = (b + a) % MODADLER;
    }

    return (b << 16) | a;
}

unsigned retrieve_index_from_hash(const long long hash, const unsigned capacity)
{
    return (capacity - 1) & (hash ^ (hash >> 12));
}

void resize(hash_set_t *set)
{
    void **keys_resized = calloc((set->capacity <<= 1), sizeof(void **));

    for (int i = 0; i < set->length; i++)
    {
        keys_resized[retrieve_index_from_hash(hash(set->values[i]),
                                              set->capacity)] = set->values[i];
    }

    free(set->keys);

    set->keys = keys_resized;

    void **new_values =
        (void **)realloc(set->values, set->capacity * sizeof(void **));
    set->values = new_values;
}
#include <stdio.h>

#include "hash_set.h"

int main()
{
    hash_set_t *set = init_hash_set();

    int v1 = 10, v2 = 20, v3 = 30, v4 = 40, v5 = 50, v6 = 60, v7 = 70;

    printf("Value %d was add ? %d\n", v1, add(set, &v1));
    printf("Value %d was add ? %d\n", v1, add(set, &v1));
    printf("contains %d ? %d\n", v1, contains(set, &v1));

    printf("Value %d was add ? %d\n", v2, add(set, &v2));
    printf("Value %d was add ? %d\n", v2, add(set, &v2));
    printf("contains %d ? %d\n", v2, contains(set, &v2));

    printf("Value %d was add ? %d\n", v3, add(set, &v3));
    printf("Value %d is add ? %d\n", v3, add(set, &v3));
    printf("contains %d ? %d\n", v3, contains(set, &v3));

    printf("Value %d was add ? %d\n", v4, add(set, &v4));
    printf("Value %d was add ? %d\n", v4, add(set, &v4));
    printf("contains %d ? %d\n", v4, contains(set, &v4));

    printf("Value %d was add ? %d\n", v5, add(set, &v5));
    printf("Value %d was add ? %d\n", v5, add(set, &v5));
    printf("contains %d ? %d\n", v5, contains(set, &v5));

    printf("Value %d is add ? %d\n", v6, add(set, &v6));
    printf("Value %d is add ? %d\n", v6, add(set, &v6));
    printf("contains %d ? %d\n", v6, contains(set, &v6));

    printf("contains %d ? %d\n", v7, contains(set, &v7));

    delete (set, &v6);

    printf("contains %d ? %d\n", v6, contains(set, &v6));

    return 0;
}#include <stdio.h>
#include <stdlib.h>

typedef struct max_heap
{
    int *p;
    int size;
    int count;
} Heap;

Heap *create_heap(Heap *heap); 
void down_heapify(Heap *heap, int index); 
void up_heapify(Heap *heap, int index); 
void push(Heap *heap, int x);           
void pop(Heap *heap); 
int top(Heap *heap); 
int empty(Heap *heap); 
int size(Heap *heap);  

int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf("Pushing element : 10\n");
    push(head, 3);
    printf("Pushing element : 3\n");
    push(head, 2);
    printf("Pushing element : 2\n");
    push(head, 8);
    printf("Pushing element : 8\n");
    printf("Top element = %d \n", top(head));
    push(head, 1);
    printf("Pushing element : 1\n");
    push(head, 7);
    printf("Pushing element : 7\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    printf("\n");
    return 0;
}
Heap *create_heap(Heap *heap)
{
    heap = (Heap *)malloc(sizeof(Heap));
    heap->size = 1;
    heap->p = (int *)malloc(heap->size * sizeof(int));
    heap->count = 0;
    return heap;
}

void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int maximum = *((heap->p) + index);
    if (left < heap->count && maximum < *((heap->p) + left))
    {
        maximum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && maximum < *((heap->p) + right))
    {
        maximum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, right);
    }
}
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) > *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}

void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}
int size(Heap *heap) { return heap->count; }
#include <stdio.h>
#include <stdlib.h>

typedef struct min_heap
{
    int *p;
    int size;
    int count;
} Heap;

Heap *create_heap(Heap *heap); 
void down_heapify(Heap *heap, int index); 
void up_heapify(Heap *heap, int index); 
void push(Heap *heap, int x);           
void pop(Heap *heap); 
int top(Heap *heap); 
int empty(Heap *heap); 
int size(Heap *heap);  

int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf("Pushing element : 10\n");
    push(head, 3);
    printf("Pushing element : 3\n");
    push(head, 2);
    printf("Pushing element : 2\n");
    push(head, 8);
    printf("Pushing element : 8\n");
    printf("Top element = %d \n", top(head));
    push(head, 1);
    printf("Pushing element : 1\n");
    push(head, 7);
    printf("Pushing element : 7\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    printf("\n");
    return 0;
}
Heap *create_heap(Heap *heap)
{
    heap = (Heap *)malloc(sizeof(Heap));
    heap->size = 1;
    heap->p = (int *)malloc(heap->size * sizeof(int));
    heap->count = 0;
    return heap;
}

void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int minimum = *((heap->p) + index);
    if (left < heap->count && minimum > *((heap->p) + left))
    {
        minimum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && minimum > *((heap->p) + right))
    {
        minimum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, right);
    }
}
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) < *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}

void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}
int size(Heap *heap) { return heap->count; }




#include <stdio.h>
#include <stdlib.h>
#define NULL ((void *)0)

struct node
{
    int data;
    struct node *next;
};

struct node *front, *rear;


void createqueue() { front = rear = NULL; }

int empty()
{
    if (front == NULL)
        return 1;
    else
        return 0;
}

void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf("Memory overflow. Unable to insert.\n");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; 

    if (empty())
        front = rear = pnode;
    else
    {
        rear->next = pnode;
        rear = pnode;
    }
}

int removes()
{
    int min;
    struct node *follow, *follow1, *p, *p1;

    if (empty())
    {
        printf("\nQueue Underflow. Unable to remove.");
        exit(1);
    }

    
    p = p1 = front;
    follow = follow1 = NULL;
    min = front->data;
    while (p != NULL)
    {
        if (p->data < min)
        {
            min = p->data;
            follow1 = follow;
            p1 = p;
        }
        follow = p;
        p = p->next;
    }

    

    if (p1 == front) 
    {
        front = front->next;
        if (front == NULL) 
            rear = NULL;
    }
    else if (p1 == rear) 
    {
        rear = follow1;
        rear->next = NULL;
    }
    else 
        follow1->next = p1->next;

    free(p1);
    return min; 
}

void show()
{
    struct node *p;

    if (empty())
        printf("Queue empty. No data to display \n");
    else
    {
        printf("Queue from front to rear is as shown: \n");

        p = front;
        while (p != NULL)
        {
            printf("%d ", p->data);
            p = p->next;
        }

        printf("\n");
    }
}

void destroyqueue() { front = rear = NULL; }

int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf("\n\n  Menu: \n");
        printf("1:Insert \n");
        printf("2:Remove \n");
        printf("3:exit \n");
        printf("Enter your choice: ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
            printf("Enter element to be inserted: ");
            scanf("%d", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf("Element removed is: %d\n", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}






#include  <stdio.h>
#include <conio.h>
#include  <stdlib.h>
#define  NULL  0


struct  node
{
  int  data ;
  struct  node  *next ;
} ;

struct  node  *first=NULL ;
struct  node  *last=NULL ;



void  create()
{
  int  i , n ;
  struct  node  *pnode , *p ;

  printf("Enter the number of nodes required:\n") ;
  scanf("%d",&n) ;

  printf("Enter the data value of each node:\n") ;
  for(i=1 ; i<=n ; i++)
  {
    pnode=(struct node*)malloc(sizeof(struct node)) ;
    if(pnode==NULL)
    {
      printf("Memory overflow. Unable to create.\n") ;
      return ;
    }

    scanf("%d",&pnode->data) ;

    if(first==NULL)
	 first=last=pnode ;
    else
    {
	  last->next=pnode ;
	  last=pnode ;    
    }

    last->next=first ;
  }
}


void  deletenode(int  k)
{
  struct  node  *p , *follow ;

  
  p=first ;
  follow=NULL ;
  while(follow!=last)
  {
    if(p->data==k)
	  break ;
    follow=p ;
    p=p->next ;
  }

  if(follow==last)
    printf("Required node not found.\n") ;
  else
  {
    if(p==first&&p==last)  
	  first=last=NULL ;
    else if(p==first)       
    {
      first=first->next ;
      last->next=first ;
    }
    else if(p==last)      
    {
      last=follow ;
      last->next=first ;
    }
    else		
      follow->next=p->next ;

    free(p) ;
  }
}


void  traverse()
{
  struct  node  *p , *follow ;
  if(first==NULL)
    printf("Circularly Linked List Empty") ;
  else
  {
    printf("Circularly Linked List is as shown: \n") ;

    p=first ;
    follow = NULL ;
    while(follow!=last)
    {
      printf("%d " , p->data) ;
      follow=p ;
      p=p->next ;
    }

    printf("\n") ;
  }
}

void main()
{
  int  x , k , ch ;
  clrscr() ;
  do
  {
    printf("\n Menu: \n") ;
    printf("1:Create Linked List \n") ;
    printf("2:Delete Node \n") ;
    printf("3:Traverse \n") ;
    printf("4:Exit \n") ;

    printf("\nEnter your choice: ") ;
    scanf("%d",&ch) ;

    switch(ch)
    {
      case 1:
      create() ;
      break ;

      case 2:
      printf("Enter the data value of the node to be deleted: ") ;
      scanf("%d",&k) ;
      deletenode(k) ;
      break ;

      case 3:
      traverse() ;
      break ;

      case 4:
      break ;
    }
 }
 while(ch!=4) ;

 getch() ;
}



#include <stdio.h>
#include <stdlib.h>
struct node
{
    int data;
    struct node *next;
};

struct node *head1 = NULL;
struct node *head2 = NULL;


void merge()
{
    struct node *temp1 = head1;
    struct node *temp2 = head2;

    struct node *holder1 = NULL;
    struct node *holder2 = NULL;
        
    while (temp1 != NULL && temp2 != NULL)
    {
        holder1 = temp1->next;
                temp1->next = temp2;
                
        if (holder1 != NULL)
        {
                                    holder2 = temp2->next;
            temp2->next = holder1;
        }
        temp1 = holder1;
        temp2 = holder2;
                    }
}

void printlist(struct node *temp)
{
    printf("%d", temp->data);
    temp = temp->next;
    while (temp != NULL)
    {
        printf("->%d", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main()
{
            struct node *one = (struct node *)malloc(sizeof(struct node));
    struct node *two = (struct node *)malloc(sizeof(struct node));
    struct node *three = (struct node *)malloc(sizeof(struct node));
    struct node *four = (struct node *)malloc(sizeof(struct node));
    struct node *five = (struct node *)malloc(sizeof(struct node));
    struct node *six = (struct node *)malloc(sizeof(struct node));
    struct node *seven = (struct node *)malloc(sizeof(struct node));
    
    head1 = one;
    head2 = two;
        
    one->data = 1;
    one->next = three;

    two->data = 2;
    two->next = four;

    three->data = 3;
    three->next = five;

    four->data = 4;
    four->next = six;

    five->data = 5;
    five->next = seven;

    six->data = 6;
    six->next = NULL;
    
    seven->data = 7;
    seven->next = NULL;
    
    printf("Linked List 1: ");
    printlist(head1);
    printf("\nLinked List 2: ");
    printlist(head2);

        merge();

    printf("\nMerged Linked List: ");
    printlist(head1);  
    return 0;
}
#include <stdio.h>
#include <stdlib.h>


struct Node
{
    int data;
    struct Node *next;
};


void printMiddle(struct Node *head)
{
    struct Node *slow_ptr = head;
    struct Node *fast_ptr = head;

    if (head != NULL)
    {
        while (fast_ptr != NULL && fast_ptr->next != NULL)
        {
            fast_ptr = fast_ptr->next->next;
            slow_ptr = slow_ptr->next;
        }
        printf("The middle element is [%d]\n\n", slow_ptr->data);
    }
}

void push(struct Node **head_ref, int new_data)
{
    
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));

    
    new_node->data = new_data;

    
    new_node->next = (*head_ref);

    
    (*head_ref) = new_node;
}

void printList(struct Node *ptr)
{
    while (ptr != NULL)
    {
        printf("%d->", ptr->data);
        ptr = ptr->next;
    }
    printf("NULL\n");
}


int main()
{
    
    struct Node *head = NULL;
    int i;

    for (i = 5; i > 0; i--)
    {
        push(&head, i);
        printList(head);
        printMiddle(head);
    }

    return 0;
}




#include <stdio.h>
#include <stdlib.h>
#define NULL 0

struct node
{
    int data;
    struct node *next;
};

struct queue
{
    struct node *front, *rear;
};

struct queue q;


void createqueue() { q.front = q.rear = NULL; }

int empty()
{
    if (q.front == NULL)
        return 1;
    else
        return 0;
}

void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf("Memory overflow. Unable to insert.\n");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; 

    if (empty())
        q.front = q.rear = pnode;
    else
    {
        (q.rear)->next = pnode;
        q.rear = pnode;
    }
}

int removes()
{
    int x;
    struct node *p;

    if (empty())
    {
        printf("Queue Underflow. Unable to remove.\n");
        exit(1);
    }

    p = q.front;
    x = (q.front)->data;
    q.front = (q.front)->next;
    if (q.front == NULL) 
        q.rear = NULL;
    free(p);
    return x;
}

void show()
{
    struct node *p;

    if (empty())
        printf("Queue empty. No data to display \n");
    else
    {
        printf("Queue from front to rear is as shown: \n");

        p = q.front;
        while (p != NULL)
        {
            printf("%d ", p->data);
            p = p->next;
        }

        printf("\n");
    }
}

void destroyqueue() { q.front = q.rear = NULL; }

int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf("\n\n  Menu: \n");
        printf("1:Insert \n");
        printf("2:Remove \n");
        printf("3:exit \n");
        printf("Enter your choice: ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
            printf("Enter element to be inserted: ");
            scanf("%d", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf("Element removed is: %d\n", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}

#include <stdio.h>
struct node
{
    int info;
    struct node *link;
};
struct node *start = NULL;
struct node *createnode()  {
    struct node *t;
    t = (struct node *)malloc(sizeof(struct node));
    return (t);
}
void insert()  {
    struct node *p;
    p = createnode();
    printf("\nenter the number to insert");
    scanf("%d", &p->info);
    p->link = NULL;
    if (start == NULL)
    {
        start = p;
    }
    else
    {
        p->link = start;
        start = p;
    }
}
void deletion()  {
    struct node *t;
    if (start == NULL)
    {
        printf("\nlist is empty");
    }
    else
    {
        struct node *p;
        p = start;
        start = start->link;
        free(p);
    }
}
void viewlist()  {
    struct node *p;
    if (start == NULL)
    {
        printf("\nlist is empty");
    }
    else
    {
        p = start;
        while (p != NULL)
        {
            printf("%d ", p->info);
            p = p->link;
        }
    }
}

int main()
{
    int n;
    while (1)
    {
        printf("\n1.add value at first location");
        printf("\n2.delete value from first location");
        printf("\n3.view value");
        printf("\nenter your choice");
        scanf("%d", &n);
        switch (n)
        {
        case 1:
            insert();
            break;
        case 2:
            deletion();
            break;
        case 3:
            viewlist();
            break;
        default:
            printf("\ninvalid choice");
        }
    }
    return (0);
}
#include <stdio.h>
#include <stdlib.h>
struct node
{
    int info;
    struct node *link;
};
struct node *top = NULL, *temp;
void push(struct node *);
void pop(struct node *);
void display(struct node *);

int main()
{
    int x = 0, item;
    printf("\t****stack using linked list****\n");
    while (x != 4)
    {
        printf("enter your choice");
        printf("\n1.push\n2.pop\n3.display\n4.exit\n");
        scanf("%d", &x);
        switch (x)
        {
        case 1:
            push(top);
            break;
        case 2:
            pop(top);
            break;
        case 3:
            display(top);
            break;
        case 4:
            return 0;
        }
    }
}

void push(struct node *p)
{
    int item;
    struct node *temp;
    temp = (struct node *)malloc(sizeof(struct node));
    printf("enter element to be inserted\n");
    scanf("%d", &item);
    temp->info = item;

    temp->link = top;
    top = temp;

    printf("inserted succesfully\n");
}
void pop(struct node *p)
{
    int item;
    struct node *temp;

    if (top == NULL)
        printf("stack is empty\n");
    else
    {
        item = top->info;
        temp = top;
        top = top->link;
        free(temp);
        printf("Element popped is%d\n", item);
    }
}

void display(struct node *p)
{
    if (top == NULL)
        printf("stack is empty\n");
    else
    {
        printf("Elements in the stack are\n");
        while (p != NULL)
        {
            printf("%d\n", p->info);
            p = p->link;
        }
            }
}
#include "list.h"
#include <assert.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#define L List_T


L List_init(void)
{
    L list;
    list = (L)malloc(sizeof(L));
    list->next = NULL;
    return list;
}


L List_push(L list, void *val)
{
    L new_elem = (L)malloc(sizeof(L));
    new_elem->val = val;
    new_elem->next = list;
    return new_elem;
}


int List_length(L list)
{
    int n;
    for (n = 0; list; list = list->next) n++;
    return n;
}


void **List_toArray(L list)
{
    int i, n = List_length(list);
    void **array = (void **)malloc((n + 1) * sizeof(*array));

    for (i = 0; i < n; i++)
    {
        array[i] = list->val;
        list = list->next;
    }
    array[i] = NULL;
    return array;
}


L List_list(L list, void *val, ...)
{
    va_list ap;
    L *p = &list;

    va_start(ap, val);
    for (; val; val = va_arg(ap, void *))
    {
        *p = malloc(sizeof(L));
        (*p)->val = val;
        p = &(*p)->next;
    }
    *p = NULL;
    va_end(ap);
    return list;
}


L List_append(L list, L tail)
{
    L *p = &list;
    while ((*p)->next)
    {
        p = &(*p)->next;
    }

    *p = tail;
    return list;
}
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "list.h"

void print_list(char **array)
{
    int i;
    for (i = 0; array[i]; i++) printf("%s", array[i]);
    printf("\n");
}

int main()
{
    List_T list1, list2, list3;
    char **str1 = (char **)malloc(100 * sizeof(char *));

    list1 = List_init();
    list1 = List_push(list1, "Dang ");
    list1 = List_push(list1, "Hoang ");
    list1 = List_push(list1, "Hai ");
    printf("List 1: ");
    str1 = (char **)List_toArray(list1);
    print_list(str1);

    list2 = List_init();
    list2 = List_list(list2, "Mentor ", "Graphics ", "Siemens", NULL);
    printf("List 2: ");
    print_list((char **)List_toArray(list2));

    list3 = List_append(list1, list2);
    printf("Test append list2 into list1: ");
    print_list((char **)List_toArray(list3));

    return 0;
}
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 100

struct node
{
    char data;
    struct node *link;
};

int c = 0;          struct node *head;  
void push(char x)  {
    struct node *p = head, *temp;
    temp = (struct node *)malloc(sizeof(struct node));
    temp->data = x;
    if (head ==
        NULL)      {
        head = temp;
        p = head;
        p->link = NULL;
        c++;
    }
    else
    {
        temp->link = p;
        p = temp;
        head = p;
        c++;
    }
}

char pop(void)  {
    char x;
    struct node *p = head;
    x = p->data;
    head = p->link;
    free(p);
    c--;
    return x;
}

int isBalanced(char *s)
{
    int i = 0;
    char x;
    while (s[i] != '\0')      {
                if (s[i] == '{' || s[i] == '(' ||
            s[i] == '[')              push(s[i]);
        else
        {
            if (c <= 0)                                           return 0;

            x = pop();
            if (x == '{' && s[i] != '}')
                return 0;
            if (x == '[' && s[i] != ']')
                return 0;
            if (x == '(' && s[i] != ')')
                return 0;
        }
        i++;
    }

            return (c == 0) ? 1 : 0;
}

void destroyStack(void)
{
    struct node *p = head;
    if (c > 0)
    {
        while (p->link)
        {
            struct node *tmp = p;
            p = p->link;
            free(tmp);
        }

        c = 0;
    }
}

int main(void)
{
    int t;
    printf("\t\tBalanced parenthesis\n\n");
    printf("\nPlease enter the number of processing rounds? ");
    scanf("%d", &t);
    for (int a0 = 0; a0 < t; a0++)
    {
        char s[SIZE];
        printf("\nPlease enter the expression? ");
        scanf("%s", s);

        if (isBalanced(s))
            printf("\nYES\n");
        else
            printf("\nNO\n");

        
        destroyStack();
    }
    return 0;
}


#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "stack.h"


void **array;


int max = 10;


int counter = 0;


int offset = -1;

void initStack()
{
    array = malloc(sizeof(void *) * max);
    assert(array); 
}


void grow()
{
    max += 10; 

    int i;      void **tmp = malloc(sizeof(void *) * max);

    
    for (i = 0; i < max - 10; i++)
    {
        *(tmp + i) = *(array + i);
    }
    
    free(array);
    array = tmp;
}


void push(void *object)
{
    assert(object); 

    if (counter < max)
    {
        offset++; 

        
        *(array + offset) = object;

        
        counter++;
    }
    else 
    {
        grow();       
        push(object); 
    }
}


void *pop()
{
    void *top = *(array + offset);

    
    assert(top);

    
    assert(!isEmpty());

    
    offset--;

    
    counter--;

    return top;
}


int size() { return counter; }


int isEmpty() { return counter == 0; }


void *top()
{
    
    return array[offset];
}

#include <stdio.h>

void push();
void pop();
void peek();
void update();

int a[100], top = -1;

int main()
{
    int x;
    while (1)
    {
        printf("\n0.exit");
        printf("\n1.push");
        printf("\n2.pop");
        printf("\n3.peek");
        printf("\n4.update");
        printf("\nenter your choice? ");
        scanf("%d", &x);
        switch (x)
        {
        case 0:
            return 0;
        case 1:
            push();
            break;
        case 2:
            pop();
            break;
        case 3:
            peek();
            break;
        case 4:
            update();
            break;
        default:
            printf("\ninvalid choice");
        }
    }
    return (0);
}

void push()
{
    int n = 0;
    printf("\nenter the value to insert? ");
    scanf("%d", &n);
    top += 1;
    a[top] = n;
}

void pop()
{
    if (top == -1)
    {
        printf("\nstack is empty");
    }
    else
    {
        int item;
        item = a[top];
        top -= 1;
        printf("\npoped item is %d ", item);
    }
}

void peek()
{
    if (top >= 0)
        printf("\n the top element is %d", a[top]);
    else
        printf("\nstack is empty");
}

void update()
{
    int i, n;
    printf("\nenter the position to update? ");
    scanf("%d", &i);
    printf("\nenter the item to insert? ");
    scanf("%d", &n);
    if (top - i + 1 < 0)
    {
        printf("\nunderflow condition");
    }
    else
    {
        a[top - i + 1] = n;
    }
}




#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALPHABET_SIZE 26


typedef struct TrieNode
{
    struct TrieNode *children[ALPHABET_SIZE];
    char character;
    bool isEndOfWord;

} TrieNode;


TrieNode *createTrieNode()
{
    TrieNode *node;
    node = malloc(sizeof(TrieNode));
    node->isEndOfWord = false;
    int i = 0;
    while (i < ALPHABET_SIZE)
    {
        node->children[i] = NULL;
        i++;
    }
    return node;
}


void insert(TrieNode *root, char *word)
{
    

        if ((strlen(word) - 1) != 0)
    {
        char character = *word;
        if (root->children[character - 97] == NULL)
        {
            TrieNode *node = NULL;
            node = createTrieNode();
            node->character = character;
            root->children[character - 97] = node;
        }
        word++;
        insert(root->children[character - 97], word);
    }
    else
    {
        root->isEndOfWord = true;
    }
    return;
}


TrieNode *search(TrieNode *root, char *word)
{
    TrieNode *temp;
    while (*word != '\0')
    {
        char character = *word;
        if (root->children[character - 97] != NULL)
        {
            temp = root->children[character - 97];
            word++;
            root = temp;
        }
        else
        {
            printf("No possible words!!\n");
            return NULL;
        }
    }
    return root;
}


void printArray(char chars[], int len)
{
    int i;
    for (i = 0; i < len; i++)
    {
        printf("%c", chars[i]);
    }
    printf("\n");
}


void printPathsRecur(TrieNode *node, char prefix[], int filledLen)
{
    if (node == NULL)
        return;

    prefix[filledLen] = node->character;
    filledLen++;

    if (node->isEndOfWord)
    {
        printArray(prefix, filledLen);
    }

    int i;
    for (i = 0; i < ALPHABET_SIZE; i++)
    {
        printPathsRecur(node->children[i], prefix, filledLen);
    }
}


void traverse(char prefix[], TrieNode *root)
{
    TrieNode *temp = NULL;
    temp = search(root, prefix);
    int j = 0;
    while (prefix[j] != '\0')
    {
        j++;
    }
    printPathsRecur(temp, prefix, j - 1);
}



#define NUMBER_OF_WORDS (354935)
#define INPUT_WORD_SIZE (100)


char *receiveInput(char *s)
{
    scanf("%99s", s);
    return s;
}

int main()
{
        int word_count = 0;
    char *words[NUMBER_OF_WORDS];
    FILE *fp = fopen("dictionary.txt", "r");

    if (fp == 0)
    {
        fprintf(stderr, "Error while opening dictionary file");
        exit(1);
    }

    words[word_count] = malloc(INPUT_WORD_SIZE);

    while (fgets(words[word_count], INPUT_WORD_SIZE, fp))
    {
        word_count++;
        words[word_count] = malloc(INPUT_WORD_SIZE);
    }

        TrieNode *root = NULL;
    root = createTrieNode();
    int i;
    for (i = 0; i < NUMBER_OF_WORDS; i++)
    {
        insert(root, words[i]);
    }

    while (1)
    {
        printf("Enter keyword: ");
        char str[100];
        receiveInput(str);
        printf(
            "\n==========================================================\n");
        printf("\n********************* Possible Words ********************\n");

                traverse(str, root);

        printf(
            "\n==========================================================\n");
    }
}
#include <ctype.h>
#include <stdio.h>
#include <string.h>

char *abbreviate(const char *phrase)
{
    char str[80];
    strcpy(str, phrase);
    char *p_str = str;
    static char acr[80];
    strcpy(acr, "");

    
    int counter = 0;

    
    int index = 0;

    
    int i = 0;

    
    while (p_str && (i < 80))
    {
        if (*p_str == ' ')
        {
            counter++;
        }
        if (i < 80)
        {
            p_str++;
            i++;
        }
    }

    i = 0;
    counter++;
    char **words = (char **)malloc(counter * sizeof(char *));

    
    for (i = 0; i < counter; i++)
    {
        words[i] = (char *)malloc(80 * sizeof(char));
        strcpy(words[i], "");
    }

    
    p_str = str;

    char *p_start = p_str;

    
    while (p_str && (i <= 80))
    {
        if (*p_str == ' ')
        {
            *p_str = '\0';
            strncat(words[index], p_start, 80);
            index++;
            p_start = p_str + 1;
        }

        if (i <= 80)
        {
            p_str++;
            i++;
        }
    }

    
    *p_str = '\0';
    strncat(words[index], p_start, 80);
    index++;

    
    for (i = 0; i < index; i++)
    {
        
        words[i][0] = toupper(words[i][0]);
        words[i][1] = '\0';
        strcat(acr, words[i]);
    }

    for (i = 0; i < counter; i++) free(words[i]);
    free(words);

    return acr;
}
#include "hello_world.h"
#include <stdlib.h>
#include <string.h>

const char *hello(void)
{
    char *ans = strdup("Hello, World!");
    
    return ans;
}
#include <stdbool.h>
#include <string.h>


bool is_isogram(const char phrase[])
{
    
    unsigned int i = 0;
    unsigned int j = 0;

    
    char current_char = ' ';

    
    bool status = true;

    
    unsigned int len_phrase = strlen(phrase);

    for (i = 0; i < len_phrase; i++)
    {
        current_char = phrase[i];

        
        for (j = i + 1; j < len_phrase; j++)
        {
            if (current_char == phrase[j])
            {
                status = false;

                
                goto end;
            }
        }
    }


end:
    return status;
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *to_rna(const char s[])
{
    
    int len = strlen(s);

    
    char *ans = malloc(sizeof(char) * len);

    
    int i = 0;

    
    for (i = 0; i < len; i++)
    {
        switch (s[i])
        {
        case 'G':
            ans[i] = 'C';
            break;
        case 'C':
            ans[i] = 'G';
            break;
        case 'T':
            ans[i] = 'A';
            break;
        case 'A':
            ans[i] = 'U';
            break;
        }
    }

    return ans;
}#include "word_count.h"
#include <string.h>


int word_count(const char *input_text, word_count_word_t *words)
{
    char word_list[MAX_WORDS][MAX_WORD_LENGTH];
    char input[1000];
    strcpy(input, input_text);
    char *p_str = input;

    
    int index = 0;

    
    int index_list = 0;

    
    int count_all = 0;

    
    int loop = 1;

    
    int i = 0;

    
    while (input[index] && loop)
    {
        if (input[index] == ' ')
        {
            input[index] = '\0';
            if (strlen(p_str) <= MAX_WORD_LENGTH)
            {
                if (index_list <= MAX_WORDS)
                {
                    strcpy(word_list[index_list], p_str);

                    
                    p_str = input + index + 1;
                    index_list++;

                    
                    count_all++;
                }
                else 
                {
                    count_all = EXCESSIVE_NUMBER_OF_WORDS;
                    loop = 0;
                }
            }
            else 
            {
                count_all = EXCESSIVE_LENGTH_WORD;
                loop = 0;
            }
        }

        index++;
    }

    words->count = 0;

    
    if (loop)
    {
        
        strcpy(word_list[index_list], p_str);
        count_all++;

        for (i = 0; i <= index_list; i++)
        {
            if (strcmp(word_list[i], words->text) == 0)
            {
                words->count++;
            }
        }
    }

    
    return count_all;
}int *twoSum(int *nums, int numsSize, int target, int *returnSize)
{
    int i, j;
    int *ret = calloc(2, sizeof(int));
    for (i = 0; i < numsSize; i++)
    {
        int key = target - nums[i];
        for (j = i + 1; j < numsSize; j++)
            if (nums[j] == key)
            {
                ret[0] = i;
                ret[1] = j;
            }
    }
    *returnSize = 2;
    return ret;
}


bool checkSymmetric(struct TreeNode *left, struct TreeNode *right)
{
    if (!left || !right)
        return left == right;
    if (left->val != right->val)
        return 0;
    return checkSymmetric(left->left, right->right) &&
           checkSymmetric(left->right, right->left);
}

bool isSymmetric(struct TreeNode *root)
{
    return root == NULL || checkSymmetric(root->left, root->right);
}


int maxval(int a, int b)
{
    if (a > b)
        return a;
    else
        return b;
}
int maxDepth(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + maxval(maxDepth(root->left), maxDepth(root->right));
}


struct TreeNode *convertBST(int *nums, int left, int right)
{
    if (left > right)
        return NULL;
    else
    {
        int mid = (right + left) / 2;
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = nums[mid];
        new_val->left = convertBST(nums, left, mid - 1);
        new_val->right = convertBST(nums, mid + 1, right);
        return new_val;
    }
}

struct TreeNode *sortedArrayToBST(int *nums, int numsSize)
{
    if (numsSize == 0)
        return NULL;
    else
        return convertBST(nums, 0, numsSize - 1);
}
void duplicateZeros(int *arr, int arrSize)
{
    int i, start = 0;
    int *tmp = malloc(arrSize * sizeof(int));
    
    for (i = 0; i < arrSize; i++)
    {
        tmp[i] = arr[i];
    }
    i = 0;
    for (start = 0; start < arrSize; start++)
    {
        arr[start] = tmp[i];
        if (tmp[i] == 0)
        {
            start++;
            if (start < arrSize)
                arr[start] = 0;
        }
        i++;
    }
}
struct TreeNode *buildBST(struct ListNode *head, struct ListNode *tail)
{
    if (head == tail)
        return NULL;
    struct ListNode *slow = head, *fast = head;
    while (fast != tail && fast->next != tail)
    {
        fast = fast->next->next;
        slow = slow->next;
    }
    struct TreeNode *node = malloc(sizeof(struct TreeNode));
    node->val = slow->val;
    node->left = buildBST(head, slow);
    node->right = buildBST(slow->next, tail);
    return node;
}
struct TreeNode *sortedListToBST(struct ListNode *head)
{
    if (!head)
        return NULL;
    else
        return buildBST(head, NULL);
}
int min(int a, int b) { return ((a < b) ? a : b); }

int maxArea(int *height, int heightSize)
{
        int start = 0;
    int end = heightSize - 1;
    int res = 0;

    while (start < end)
    {
                int currArea = (end - start) * min(height[start], height[end]);

        if (currArea > res)
            res = currArea;

        if (height[start] < height[end])
            start = start + 1;
        else
            end = end - 1;
    }

    return res;
}
int max(int a, int b) { return a >= b ? a : b; }

int height(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + max(height(root->left), height(root->right));
}

bool isBalanced(struct TreeNode *root)
{
    if (root == NULL)
        return 1;
    int left = height(root->left);
    int right = height(root->right);
    return abs(left - right) <= 1 && isBalanced(root->left) &&
           isBalanced(root->right);
}
bool hasPathSum(struct TreeNode *root, int sum)
{
    if (root == NULL)
        return 0;
    if (!root->left && !root->right && sum - root->val == 0)
        return 1;
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
}
int distanceBetweenBusStops(int *distance, int distanceSize, int start,
                            int destination)
{
    int sum1 = 0, sum2 = 0;
    if (start > destination)
    {
        int tmp = start;
        start = destination;
        destination = tmp;
    }
    for (auto i = 0; i < distanceSize; ++i)
    {
        if (i >= start && i < destination)
            sum1 += distance[i];
        else
            sum2 += distance[i];
    }
    return sum1 < sum2 ? sum1 : sum2;
}
int maxNumberOfBalloons(char *text)
{
    
    int count_letters[5] = {0};
    int i, min_counter_ballons;

    for (char *ptr = text; *ptr; ptr++)
    {
        if (*ptr == 'b')
        {
            count_letters[0]++;
        }
        else if (*ptr == 'a')
        {
            count_letters[1]++;
        }
        else if (*ptr == 'l')
        {
            count_letters[2]++;
        }
        else if (*ptr == 'o')
        {
            count_letters[3]++;
        }
        else if (*ptr == 'n')
        {
            count_letters[4]++;
        }
    }

    
    count_letters[2] /= 2;
    count_letters[3] /= 2;

    
    min_counter_ballons = count_letters[0];
    for (i = 1; i < 5; i++)
    {
        if (count_letters[i] < min_counter_ballons)
            min_counter_ballons = count_letters[i];
    }

    return min_counter_ballons;
}
char *getOne(char c)
{
    switch (c)
    {
    case '9':
        return "IX";

    case '8':
        return "VIII";

    case '7':
        return "VII";

    case '6':
        return "VI";

    case '5':
        return "V";

    case '4':
        return "IV";

    case '3':
        return "III";

    case '2':
        return "II";

    case '1':
        return "I";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getTen(char c)
{
    switch (c)
    {
    case '9':
        return "XC";

    case '8':
        return "LXXX";

    case '7':
        return "LXX";

    case '6':
        return "LX";

    case '5':
        return "L";

    case '4':
        return "XL";

    case '3':
        return "XXX";

    case '2':
        return "XX";

    case '1':
        return "X";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getHundred(char c)
{
    switch (c)
    {
    case '9':
        return "CM";

    case '8':
        return "DCCC";

    case '7':
        return "DCC";

    case '6':
        return "DC";

    case '5':
        return "D";

    case '4':
        return "CD";

    case '3':
        return "CCC";

    case '2':
        return "CC";

    case '1':
        return "C";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getThousand(char c)
{
    switch (c)
    {
    case '3':
        return "MMM";

    case '2':
        return "MM";

    case '1':
        return "M";

    default:
        return NULL;
    }
}

char *intToRoman(int num)
{
    int length;
    char number[5];
    char *s = malloc(16 * sizeof(char));

    sprintf(number, "%i", num);

    length = strlen(number);

    switch (length)
    {
    case 4:
        sprintf(s, "%s%s%s%s", getThousand(number[0]), getHundred(number[1]),
                getTen(number[2]), getOne(number[3]));
        break;

    case 3:
        sprintf(s, "%s%s%s", getHundred(number[0]), getTen(number[1]),
                getOne(number[2]));

        break;

    case 2:
        sprintf(s, "%s%s", getTen(number[0]), getOne(number[1]));

        break;

    case 1:
        s = getOne(number[0]);
        break;

    default:
        break;
    }
    return s;
}
#define MAP_SIZE 2048

int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }
bool uniqueOccurrences(int *arr, int arrSize)
{
    int *map = calloc(MAP_SIZE, sizeof(int));
    int i;
    for (i = 0; i < arrSize; i++)
    {
        if (arr[i] < 0)
            map[arr[i] + MAP_SIZE / 2] += 1;
        else
            map[arr[i]] += 1;
    }
    
    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);
    i = 0;
    while (map[i])
    {
        if (map[i] == map[i + 1])
            return 0;
        i++;
    }
    return 1;
}
int maxcmp(int a, int b) { return (a >= b) ? a : b; }


int maxProfit(int *prices, int pricesSize)
{
    
    int maxCur = 0, maxSoFar = 0;
    for (int i = 1; i < pricesSize; i++)
    {
        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);
        maxSoFar = maxcmp(maxSoFar, maxCur);
    }
    return maxSoFar;
}
bool isPalindrome(char *s)
{
    int start = 0, end = strlen(s) - 1;
    while (start < end)
    {
        if (!isalpha(s[start]) && !isalnum(s[start]))
        {
            start++;
        }
        else if (!isalpha(s[end]) && !isalnum(s[end]))
        {
            end--;
        }
        else
        {
            char c1 = tolower(s[start]);
            char c2 = tolower(s[end]);
            if (c1 != c2)
                return 0;
            start++;
            end--;
        }
    }
    return 1;
}
int romanToInt(char *s)
{
    int romanToInt = 0;
    for (int i = 0; i < strlen(s); i++)
    {
        switch (s[i])
        {
        case 'I':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'V' || s[i + 1] == 'X')
                {
                    romanToInt -= 1;
                    break;
                }
            }
            romanToInt += 1;
            break;
        case 'V':
            romanToInt += 5;
            break;
        case 'X':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'L' || s[i + 1] == 'C')
                {
                    romanToInt -= 10;
                    break;
                }
            }
            romanToInt += 10;
            break;
        case 'L':
            romanToInt += 50;
            break;
        case 'C':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'D' || s[i + 1] == 'M')
                {
                    romanToInt -= 100;
                    break;
                }
            }
            romanToInt += 100;
            break;
        case 'D':
            romanToInt += 500;
            break;
        case 'M':
            romanToInt += 1000;
            break;
        default:
            break;
        }
    }
    return romanToInt;
}int singleNumber(int *nums, int numsSize)
{
    int i, result = 0;
    for (i = 0; i < numsSize; i++) result = result ^ nums[i];
    return result;
}

bool hasCycle(struct ListNode *head)
{
    struct ListNode *fast = head, *slow = head;
    while (slow && fast && fast->next)
    {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            return true;
    }
    return false;
}
struct ListNode *detectCycle(struct ListNode *head)
{
    if (head == NULL || head->next == NULL)
        return NULL;
    struct ListNode *slow, *fast;
    slow = fast = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
        {
            struct ListNode *entry = head;
            while (slow != entry)
            {
                slow = slow->next;
                entry = entry->next;
            }
            return entry;
        }
    }
    return NULL;
}
int findMin(int *nums, int numsSize)
{
    int low = 0, high = numsSize - 1;
    while (low < high)
    {
        int mid = low + (high - low) / 2;
        
        if (nums[mid] < nums[high])
            high = mid;
        
        else
            low = mid + 1;
    }
    return nums[low];
}
struct ListNode *getIntersectionNode(struct ListNode *headA,
                                     struct ListNode *headB)
{
    struct ListNode *cur1 = headA, *cur2 = headB;
    if (cur1 == NULL || cur2 == NULL)
        return NULL;
    while (cur1 && cur2 && cur1 != cur2)
    {
        cur1 = cur1->next;
        cur2 = cur2->next;
        if (cur1 == cur2)
            return cur1;
        if (!cur1)
            cur1 = headB;
        if (!cur2)
            cur2 = headA;
    }
    return cur1;
}

int majorityElement(int *nums, int numsSize)
{
    int count = 1;
    int majorNum = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        if (count == 0)
        {
            majorNum = nums[i];
            count++;
        }
        else if (majorNum == nums[i])
            count++;
        else
            count--;
    }
    return majorNum;
}


#include <limits.h>

typedef struct
{
    int *values;
    int CurrentIndex;
    int NumberOfNodes;
} BSTIterator;

void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)
{
    if (!root)
        return;
    if (root->left)
        TraverseAndAssign(root->left, obj);
    obj->values[obj->CurrentIndex] = root->val;
    obj->CurrentIndex++;
    if (root->right)
        TraverseAndAssign(root->right, obj);
}

int TotalNodes(struct TreeNode *root)
{
    if (!root)
        return 0;
    int nodes_left = TotalNodes(root->left);
    int nodes_right = TotalNodes(root->right);
    return nodes_left + nodes_right + 1;
}

BSTIterator *bSTIteratorCreate(struct TreeNode *root)
{
    int n = TotalNodes(root);
    int size = n + 1;
    printf("%d", size);
    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));
    obj->values = (int *)calloc(size, sizeof(int));
    obj->CurrentIndex = 0;
    obj->NumberOfNodes = n;
    obj->values[size - 1] = INT_MAX;
    TraverseAndAssign(root, obj);
    obj->CurrentIndex = 0;
    return obj;
}


int bSTIteratorNext(BSTIterator *obj)
{
    int NextValue = obj->values[obj->CurrentIndex];
    obj->CurrentIndex++;
    return NextValue;
}


bool bSTIteratorHasNext(BSTIterator *obj)
{
    if (!obj->NumberOfNodes)
    {
        return false;
    }
    printf(" Here ");
    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;
}

void bSTIteratorFree(BSTIterator *obj)
{
    free(obj->values);
    free(obj);
}
void rotate(int *nums, int numsSize, int k)
{
    for (int i = 1; i <= k; i++)
    {
        int j;
        int lastElement;
        lastElement = nums[numsSize - 1];
        for (j = numsSize - 1; j > 0; j--)
        {
            nums[j] = nums[j - 1];
        }
        nums[0] = lastElement;
    }
}uint32_t reverseBits(uint32_t n)
{
    uint TotalBits = 32;
    uint32_t reverse_int = 0;      uint i;
    for (i = 0; i < TotalBits; i++)
    {
        if ((n & (UINT32_C(1)
                  << i)))                                                                                                                          reverse_int =
                reverse_int |
                (UINT32_C(1)
                 << (TotalBits - 1 -
                     i));                                                                                                                                             }
    return reverse_int;
}int hammingWeight(uint32_t n)
{
    int TotalBits = 32;
    int i, weight = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (n &
            (UINT32_C(1)
             << i))                                                                             weight += 1;
    }
    return weight;
}

struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *head = NULL;
    struct ListNode *walk = NULL;
    struct ListNode *tmp = NULL;

    int carry = 0;
    int val1 = 0;
    int val2 = 0;
    int val = 0;

    while (l1 != NULL || l2 != NULL || carry)
    {
        val1 = 0;
        val2 = 0;
        val = 0;

        if (l1)
        {
            val1 = l1->val;
            l1 = l1->next;
        }

        if (l2)
        {
            val2 = l2->val;
            l2 = l2->next;
        }

        val = carry + val1 + val2;
        carry = val / 10;

        tmp = malloc(sizeof(struct ListNode));
        tmp->val = val % 10;
        tmp->next = NULL;

        if (!head)
        {
            head = walk = tmp;
        }
        else
        {
            walk->next = tmp;
            walk = walk->next;
        }
    }

    return head;
}
bool isValid(char *s)
{
    int i, k = 0, len = strlen(s);
    char *store = calloc(len, sizeof(char));

    for (i = 0; s[i] != '\0'; i++)
    {
        switch (s[i])
        {
        case '(':
        case '{':
        case '[':
            store[k++] = s[i];
            break;
        case ')':
            if (k < 1 || store[--k] != '(')
                goto out;
            break;
        case '}':
            if (k < 1 || store[--k] != '{')
                goto out;
            break;
        case ']':
            if (k < 1 || store[--k] != '[')
                goto out;
            break;
        }
    }
out:
    free(store);
    return s[i] == '\0' && k == 0;
}
int rangeBitwiseAnd(int m, int n)
{
    while (m < n)
    {
        n &= n - 1;
    }
    return n;
}struct ListNode *removeElements(struct ListNode *head, int val)
{
    if (head == NULL)
        return NULL;
    if (head->val == val)
    {
        return removeElements(head->next, val);
    }
    else
    {
        head->next = removeElements(head->next, val);
    }
    return head;
}


struct ListNode *reverseList(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}

struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *list = NULL;
    struct ListNode *tmp = NULL;

    if (!l1)
        return l2;
    if (!l2)
        return l1;

    if (l1 && l2)
    {
        if (l1->val < l2->val)
        {
            list = tmp = l1;
            l1 = l1->next;
        }
        else
        {
            list = tmp = l2;
            l2 = l2->next;
        }

        while (l1 && l2)
        {
            if (l1->val < l2->val)
            {
                tmp->next = l1;
                l1 = l1->next;
            }
            else
            {
                tmp->next = l2;
                l2 = l2->next;
            }
            tmp = tmp->next;
        }

        if (l1)
            tmp->next = l1;
        if (l2)
            tmp->next = l2;

        return list;
    }

    return NULL;
}


struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    if (!l1)
        return l2;
    if (!l2)
        return l1;
    if (l1->val < l2->val)
    {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else
    {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
int *cmpval(const void *a, const void *b) { return *(int *)b - *(int *)a; }

int findKthLargest(int *nums, int numsSize, int k)
{
    qsort(nums, numsSize, sizeof(int), cmpval);
    return nums[k - 1];
}
int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }

bool containsDuplicate(int *nums, int numsSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), numcmp);
    for (i = 0; i < numsSize - 1; i++)
    {
        if (nums[i] == nums[i + 1])
            return 1;
    }
    return 0;
}
struct TreeNode *invertTree(struct TreeNode *root)
{
    struct TreeNode *tmp;
    if (root == NULL)
        return NULL;
    tmp = root->left;
    root->left = root->right;
    root->right = tmp;

    invertTree(root->left);
    invertTree(root->right);
    return root;
}
bool isPowerOfTwo(int n)
{
    if (!n)
        return false;
    while (n % 2 == 0) n /= 2;
    return n == 1;
}

struct ListNode *reverse(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}
bool isPalindrome(struct ListNode *head)
{
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    struct ListNode *last;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    if (fast != NULL)
        slow = slow->next;
    last = reverse(slow);
    while (last)
    {
        if (head->val != last->val)
            return 0;
        head = head->next;
        last = last->next;
    }
    return 1;
}
struct ListNode *swapPairs(struct ListNode *head)
{
    if (!head || !head->next)
        return head;
    struct ListNode *tmp = head->next;
    head->next = swapPairs(head->next->next);
    tmp->next = head;
    return tmp;
}
bool isAnagram(char *s, char *t)
{
    int n = strlen(s);
    int m = strlen(t);

    int cnt_s[1000], cnt_t[1000];
    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;

    for (int i = 0; i < n; i++) cnt_s[s[i]]++;

    for (int i = 0; i < m; i++) cnt_t[t[i]]++;

    for (int c = 97; c < 97 + 26; c++)
        if (cnt_s[c] != cnt_t[c])
            return false;

    return true;
}
int removeDuplicates(int *nums, int numsSize)
{
    int count = 0, i;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] == nums[i - 1])
            count++;
        else
            nums[i - count] = nums[i];
    }
    return numsSize - count;
}
int missingNumber(int *nums, int numsSize)
{
    int i, actual_sum = 0, sum = 0;
    for (i = 0; i < numsSize; i++)
    {
        sum = sum + nums[i];
        actual_sum = actual_sum + i;
    }
    return actual_sum + numsSize - sum;
}
int removeElement(int *nums, int numsSize, int val)
{
    int i, start = 0;
    for (i = 0; i < numsSize; i++)
    {
        if (nums[i] != val)
            nums[start++] = nums[i];
    }
    return start;
}
bool isBadVersion(int version);

int firstBadVersion(int n)
{
    int low = 1, high = n;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (isBadVersion(mid))
        {
            high = mid - 1;
        }
        else
        {
            low = mid + 1;
        }
    }
    return low;
}

int strStr(char *haystack, char *needle)
{
    int i = 0;
    int j = 0;
    int k = 0;
    int hlen = 0;
    int nlen = 0;

    if (needle == NULL || *needle == 0)
        return 0;

    if (haystack == NULL || *haystack == 0)
        return -1;

    hlen = strlen(haystack);
    nlen = strlen(needle);

    if (hlen < nlen)
        return -1;

    for (i = 0; i <= hlen - nlen; i++)
    {
        j = 0;
        if (haystack[i] != needle[j++])
            continue;

        k = i + 1;
        for (; j < nlen; j++)
        {
            if (haystack[k] != needle[j])
            {
                break;
            }
            else
                k++;
        }
        if (j == nlen)
            return i;
    }
    return -1;
}






void fill_overlap(char *needle, int len_needle, int *overlap)
{
    int len = 0;
    int i = 0;

    overlap[0] = 0;

    for (i = 1; i < len_needle;)
    {
        if (needle[i] == needle[len])
        {
            len++;
            overlap[i++] = len;
        }
        else
        {
            if (len)
                len = overlap[len - 1];
            else
                overlap[i++] = 0;
        }
    }
}

int strStr(char *haystack, char *needle)
{
    int i = 0; 
    int j = 0; 

    int len_needle = strlen(needle);
    int len_haystack = strlen(haystack);

    if (!len_needle)
        return 0;

    int overlap[len_needle];

    fill_overlap(needle, len_needle, overlap);

    while (i < len_haystack)
    {
        if (needle[j] == haystack[i])
        {
            i++;
            j++;
        }

        if (j == len_needle)
        {
            return (i - j);
        }
        else if (i < len_haystack && needle[j] != haystack[i])
        {
            if (j != 0)
                j = overlap[j - 1];
            else
                i = i + 1;
        }
    }
    return -1;
}


void moveZeroes(int *nums, int numsSize)
{
    int i = 0, start = 0;

    for (i = 0; i < numsSize; i++)
    {
        if (nums[i])
            nums[start++] = nums[i];
    }

    for (start; start < numsSize; start++)
    {
        nums[start] = 0;
    }
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }
int findDuplicate(int *nums, int numsSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize - 1; i++)
    {
        if (nums[i] == nums[i + 1])
            return nums[i];
    }
    return nums[i];
}
int divide(int dividend, int divisor)
{
    int sign = 1;
    long int output = 0;
    if (dividend < 0)
    {
        sign *= -1;
    }
    else
    {
        dividend *= -1;
    }
    if (divisor < 0)
    {
        sign *= -1;
    }
    else
    {
        divisor *= -1;
    }
    while (dividend <= divisor)
    {
        long int tmp = 0;
        long int div = divisor;
        while (dividend <= div)
        {
            tmp += (tmp + 1);
            dividend -= div;
            div += div;
        }
        if (output >= INT_MAX)
        {
            if (sign == -1)
            {
                return INT_MIN;
            }
            else
            {
                return INT_MAX;
            }
        }
        output += tmp;
    }

    return output * sign;
}
int lengthOfLongestSubstring(char *str)
{
    int n = strlen(str);

    if (!n)
        return 0;

    int L_len = 1;      int C_len = 1;  
    int P_ind, i;          int visited[256];                                                    memset(visited, -1, sizeof(int) * 256);
    visited[str[0]] =
        0;      for (i = 1; i < n; i++)
    {
        P_ind = visited[str[i]];
        if (P_ind == -1 || i - C_len > P_ind)
            C_len++;                                else
        {              if (C_len > L_len)
                L_len = C_len;
            C_len = i - P_ind;
        }
        visited[str[i]] = i;
    }
    if (C_len > L_len)
        L_len = C_len;
    return L_len;
}

int lengthOfLongestSubstring(char *s)
{
    int cur_max = 0, max = 0;
    int counter[255];
    int end = 0;

    memset(counter, 0, sizeof(int) * 255);
    while (end < strlen(s))
    {
        if (counter[s[end]] == 0)
        {
            counter[s[end]]++;
            end++;
            cur_max++;
        }
        else
        {
            char c = s[end];
            memset(counter, 0, 255 * sizeof(int));
            if (cur_max >= max)
                max = cur_max;
            cur_max = 0;
            while (s[end - 1] != c) end--;
        }
    }
    if (cur_max >= max)
        max = cur_max;
    return max;
}
void reverseString(char *s, int sSize)
{
    int last = sSize - 1, i;
    for (i = 0; i < last; i++)
    {
        char tmp = s[i];
        s[i] = s[last];
        s[last] = tmp;
        last--;
    }
}
int searchInsert(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1, mid;
    while (low <= high)
    {
        mid = low + (high - low) / 2;
        if (target > nums[mid])
            low = mid + 1;
        else if (target < nums[mid])
            high = mid - 1;
        else
            return mid;
    }
    return low;
}


int searchInsert(int *nums, int numsSize, int target)
{
    int idx = numsSize - 1;
    if (numsSize > 0)
    {
        if (target > nums[idx])
        {
            return numsSize;
        }
        return searchInsert(nums, numsSize - 1, target);
    }
    return 0;
}
bool isPerfectSquare(int num)
{
    for (long i = 1; i * i <= num; i++)
        if (i * i == num)
            return true;
    return false;
}
char *countAndSay(int n)
{
        double result = 1.0;
    for (int i = 0; i < n - 1; i++)
    {
        result *= 1.4;
    }

    int k, j, count, convert = (int)result;

        char *arr = malloc(convert + 4);
    arr[0] = '1';
    arr[1] = '\0';

    for (int i = 2, length; i <= n; i++)
    {
        length = strlen(arr);
        char newArr[length * 2];
        strcpy(newArr, arr);

        k = 0;
        j = 0;
        count = 1;

        while (newArr[j] != '\0')
        {
            if (newArr[j] == newArr[j + 1])
            {
                count++;
                j++;
            }
            else
            {
                arr[k] = (48 + count);
                arr[k + 1] = newArr[j];
                arr[k + 2] = '\0';
                j++;
                k += 2;
                count = 1;
            }
        }
    }

    return arr;
}
int firstUniqChar(char *s)
{
    int *arr = calloc(256, sizeof(int));
    int i;
    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;
    for (i = 0; i < strlen(s); i++)
    {
        if (arr[s[i]] == 1)
            return i;
    }
    return -1;
}
char findTheDifference(char *s, char *t)
{
    int sum1 = 0, sum2 = 0;
    int i;
    for (i = 0; i < strlen(s); i++) sum1 += s[i];
    for (i = 0; i < strlen(t); i++) sum2 += t[i];
    return (char)(sum2 - sum1);
}


double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2,
                              int nums2Size)
{
    int index1 = 0;
    int index2 = 0;
    int v[nums1Size + nums2Size];
    int v_index = 0;

    while (index1 < nums1Size && index2 < nums2Size)
    {
        if (nums1[index1] <= nums2[index2])
        {
            v[v_index++] = nums1[index1++];
        }
        else
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (index1 < nums1Size)
    {
        while (index1 < nums1Size)
        {
            v[v_index++] = nums1[index1++];
        }
    }
    if (index2 < nums2Size)
    {
        while (index2 < nums2Size)
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (v_index == 1)
    {
        return v[0];
    }
    if (v_index % 2 == 0)
    {
        double n1, n2;
        n1 = v[v_index / 2];
        n2 = v[(v_index / 2) - 1];
        return (n1 + n2) / 2;
    }
    int new_index = (int)v_index / 2;
    int i = 0;
    return v[new_index];
}
bool isleaf(struct TreeNode *root)
{
    return root->left == NULL && root->right == NULL;
}

int sumOfLeftLeaves(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    if (root->left)
    {
        if (isleaf(root->left))
            return root->left->val + sumOfLeftLeaves(root->right);
    }
    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int *findDuplicates(int *nums, int numsSize, int *returnSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    int *retArr = malloc(numsSize * sizeof(int));
    *returnSize = 0;
    for (i = 0; i < numsSize - 1;)
    {
        if (nums[i] == nums[i + 1])
        {
            retArr[*returnSize] = nums[i];
            *returnSize = *returnSize + 1;
            i = i + 2;
        }
        else
        {
            i = i + 1;
        }
    }
    return retArr;
}
int hammingDistance(int x, int y)
{
    int difference =
        x ^ y;                                      int TotalBits = sizeof(difference) * 8;      int i, distance = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (difference &
            (UINT32_C(1)
             << i))                                                                             distance += 1;
    }
    return distance;
}int findComplement(int num)
{
    int TotalBits = 0;
    int temp = num;
    while (temp)
    {                 TotalBits++;          temp >>= 1;                             }
    int i,
        flipNumber = 1;                                                        for (i = 1; i < TotalBits; i++)
    {
        flipNumber += UINT32_C(1)
                      << i;                                   }
    num = num ^ flipNumber;
    return num;
}int fib(int N)
{
    if (N == 0)
        return 0;
    if (N == 1)
        return 1;
    return fib(N - 1) + fib(N - 2);
}
bool detectCapitalUse(char *word)
{
    int len = strlen(word);
    if (len == 1)
        return 1;
    int countUpper = 0, i;
    for (i = 0; i < len; i++)
    {
        if (isupper(word[i]))
            countUpper++;
    }
    
    if (countUpper == 0)
        return 1;
    
    if (countUpper == 1 && isupper(word[0]))
        return 1;
    
    else
        return countUpper == len;
}


bool isAllUpper(char *word)
{
    int len = strlen(word);
    for (int i = 0; i < len; i++)
    {
        if (islower(word[i]))
            return 0;
    }
    return 1;
}
bool detectCapitalUse(char *word)
{
    int len = strlen(word);
    for (int i = 1; i < len; i++)
    {
        if (isupper(word[i]) && !isAllUpper(word))
            return 0;
    }
    return 1;
}

int maxcmp(int a, int b) { return a >= b ? a : b; }

int maxSubArray(int *nums, int numsSize)
{
    int maxSoFar = nums[0], maxEndingHere = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]);
        maxSoFar = maxcmp(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }
int arrayPairSum(int *nums, int numsSize)
{
    int sum = 0, i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];
    return sum;
}
struct TreeNode *newNode(int item)
{
    struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    node->val = item;
    node->left = node->right = NULL;
    return node;
}

struct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)
{
    if (t1 == NULL && t2 == NULL)
        return NULL;
    int item = (t1 == NULL ? 0 : t1->val) + (t2 == NULL ? 0 : t2->val);
    struct TreeNode *node = newNode(item);
    node->left =
        mergeTrees(t1 == NULL ? NULL : t1->left, t2 == NULL ? NULL : t2->left);
    node->right = mergeTrees(t1 == NULL ? NULL : t1->right,
                             t2 == NULL ? NULL : t2->right);
    return node;
}



int countSubstrings(char *s)
{
    int len = strlen(s);
    int i;
    int count = 0;
    for (i = 0; i < len; i++)
    {
        
        count += countPalin(s, i, i, len);
        if (i != len - 1)
            count += countPalin(s, i, i + 1, len);
    }
    return count;
}
int countPalin(char *s, int head, int tail, int len)
{
    int ret = (s[head] == s[tail]) ? 1 : 0;
    if (ret && head - 1 >= 0 && tail + 1 < len)
        ret += countPalin(s, head - 1, tail + 1, len);
    return ret;
}

int *plusOne(int *digits, int digitsSize, int *returnSize)
{
    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (digits[i] < 9)
        {
            digits[i]++;
            *returnSize = digitsSize;
            return digits;
        }
        else
        {
            digits[i] = 0;
        }
    }

    int *newdigit = (int *)malloc((digitsSize + 1) * sizeof(int));
    newdigit[0] = 1;
    for (int i = 1; i < (digitsSize + 1); i++)
    {
        newdigit[i] = digits[i - 1];
    }
    *returnSize = digitsSize + 1;
    return newdigit;
}int findLengthOfLCIS(int *nums, int numsSize)
{
    int maxval = 1, i, count = 1;
    if (numsSize == 0)
        return 0;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] > nums[i - 1])
        {
            count++;
            if (count >= maxval)
                maxval = count;
        }
        else
        {
            count = 1;
        }
    }
    return maxval;
}
#include <limits.h>

int reverse(int x)
{
    int rev = 0;
    while (x != 0)
    {
        int pop = x % 10;
        x /= 10;
        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7))
            return 0;
        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8))
            return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}


struct TreeNode *searchBST(struct TreeNode *root, int val)
{
    if (!root)
        return NULL;

    if (root->val == val)
    {
        return root;
    }
    else if (root->val > val)
    {
        return searchBST(root->left, val);
    }
    else
    {
        return searchBST(root->right, val);
    }
}
struct TreeNode *insertIntoBST(struct TreeNode *root, int val)
{
    if (root == NULL)
    {
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = val;
        new_val->left = new_val->right = NULL;
        return new_val;
    }
    else
    {
        if (root->val >= val)
            root->left = insertIntoBST(root->left, val);
        else
            root->right = insertIntoBST(root->right, val);
    }
    return root;
}
int search(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (target > nums[mid])
        {
            low = mid + 1;
        }
        else if (target < nums[mid])
        {
            high = mid - 1;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}


int cmpint(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int search(int *nums, int numsSize, int target)
{
    int *ret = bsearch(&target, nums, numsSize, sizeof(int), cmpint);
    if (ret)
        return (ret - nums);
    else
        return -1;
}
char *toLowerCase(char *str)
{
    for (int i = 0; i < strlen(str); i++) str[i] = tolower(str[i]);
    return str;
}
#include <string.h>

int numJewelsInStones(char *j, char *s)
{
        int cnt[500], lens = strlen(s), lenj = strlen(j), sol = 0;
    memset(cnt, 0, sizeof(cnt));

        for (int i = 0; i < lenj; i++) cnt[j[i]]++;

        for (int i = 0; i < lens; i++) sol += cnt[s[i]];

    return sol;
}
int myAtoi(char *str)
{
    int minusFlag = 0;
    int length = strlen(str);
    long int result = 0;
    char numberBuffer[11];
    int counter = 0;
    while (str[counter] == ' ')
    {
        counter++;
    }
    str = &str[counter];
    counter = 0;

    for (int i = 0; i < length; i++)
    {
        if (i == 0)
        {
            if (str[0] == '-')
            {
                minusFlag = 1;
                i++;
            }
            else if (str[0] == '+')
            {
                i++;
            }
        }
        if (counter > 10)
        {
            if (minusFlag)
            {
                return __INT_MAX__ * -1 - 1;
            }
            else
            {
                return __INT_MAX__;
            }
        }

        if (str[i] < '0' || str[i] > '9')
        {
            break;
        }
        if (counter == 0 && str[i] == '0')
        {
            continue;
        }

        numberBuffer[counter] = str[i];
        counter++;
    }

    int i = 0;
    while (counter > 0)
    {
        if (minusFlag)
        {
            result -= (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        else
        {
            result += (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        i++;
        counter--;
    }

    if (result > __INT_MAX__)
    {
        return __INT_MAX__;
    }
    else if (result < __INT_MAX__ * -1 - 1)
    {
        return __INT_MAX__ * -1 - 1;
    }
    return result;
}
struct ListNode *deleteDuplicates(struct ListNode *head)
{
    if (head == NULL)
        return NULL;

    if (head->next && head->val == head->next->val)
    {
        
        while (head->next && head->val == head->next->val)
        {
            head = head->next;
        }
        return deleteDuplicates(head->next);
    }
    else
    {
        head->next = deleteDuplicates(head->next);
    }
    return head;
}

struct ListNode *deleteDuplicates(struct ListNode *head)
{
    struct ListNode *cur = head;
    while (cur && cur->next)
    {
        if (cur->val == cur->next->val)
            cur->next = cur->next->next;
        else
            cur = cur->next;
    }
    return head;
}
int peakIndexInMountainArray(int *A, int ASize)
{
    int low = 1, high = ASize;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (A[mid - 1] < A[mid] && A[mid] > A[mid + 1])
            return mid;
        else if (A[mid - 1] < A[mid] && A[mid] < A[mid + 1])
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}


struct ListNode *middleNode(struct ListNode *head)
{
    struct ListNode *fast, *slow;
    fast = slow = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
bool isPalindrome(int x)
{
    if (x < 0 || (x % 10 == 0 && x != 0))
    {
        return false;
    }

    int revertedNumber = 0;
    while (x > revertedNumber)
    {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }

    return x == revertedNumber || x == revertedNumber / 10;
}

int *sortArrayByParity(int *A, int ASize, int *returnSize)
{
    int *retArr = malloc(ASize * sizeof(int));
    int oddIndex = ASize - 1;
    int evenIndex = 0;
    *returnSize = ASize;
    for (int i = 0; i < ASize; i++)
    {
        if (A[i] % 2 == 0)
        {
            retArr[evenIndex] = A[i];
            evenIndex++;
        }
        else
        {
            retArr[oddIndex] = A[i];
            oddIndex--;
        }
    }

    return retArr;
}
char *reverseOnlyLetters(char *S)
{
    int last = strlen(S) - 1, i;
    for (i = 0; i < last;)
    {
        if (!isalpha(S[i]))
        {
            i++;
            continue;
        }
        if (!isalpha(S[last]))
        {
            last--;
            continue;
        }
        char tmp = S[i];
        S[i] = S[last];
        S[last] = tmp;
        i++;
        last--;
    }
    return S;
}
int rangeSumBST(struct TreeNode *root, int L, int R)
{
    if (root == NULL)
    {
        return 0;
    }
    else if (root->val >= L && root->val <= R)
    {
        return root->val + rangeSumBST(root->left, L, R) +
               rangeSumBST(root->right, L, R);
    }
    else
    {
        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
    }
}
void processTraversal(struct TreeNode *root, int *res, int *size)
{
    if (!root)
        return;
    processTraversal(root->left, res, size);
    res[*size] = root->val;
    *size = *size + 1;
    processTraversal(root->right, res, size);
}

int *inorderTraversal(struct TreeNode *root, int *returnSize)
{
    int *res = malloc(256 * sizeof(int));
    *returnSize = 0;
    processTraversal(root, res, returnSize);
    return res;
}
bool isUnivalTree(struct TreeNode *root)
{
    if (root == NULL)
        return 1;
    if (root->left)
    {
        if (root->left->val != root->val)
            return 0;
    }
    if (root->right)
    {
        if (root->right->val != root->val)
            return 0;
    }
    return isUnivalTree(root->left) && isUnivalTree(root->right);
}

int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int i, start = 0, end = ASize - 1;
    int *res = malloc(ASize * sizeof(int));
    *returnSize = ASize;
    for (i = ASize - 1; i >= 0; i--)
    {
        if (abs(A[start]) > A[end])
        {
            res[i] = A[start] * A[start];
            start++;
        }
        else
        {
            res[i] = A[end] * A[end];
            end--;
        }
    }
    return res;
}


int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int *res = malloc(ASize * sizeof(int));
    for (int i = 0; i < ASize; i++) res[i] = A[i] * A[i];
    *returnSize = ASize;
    qsort(res, ASize, sizeof(int), cmpval);
    return res;
}


#include <stdio.h>


int main()
{
    int t;
    printf("Enter number of times you want to try");
    scanf("%d", &t);
    while (t--)      {
        unsigned long long N, p = 0, sum = 0;
        printf("Enter the value of N ");

        scanf("%lld", &N);          p = (N - 1) / 3;
        sum = ((3 * p * (p + 1)) / 2);

        p = (N - 1) / 5;
        sum = sum + ((5 * p * (p + 1)) / 2);

        p = (N - 1) / 15;
        sum = sum - ((15 * p * (p + 1)) / 2);
        printf("%lld\n", sum);                                      }
    return 0;
}

#include <stdio.h>


int main()
{
    int n = 0;
    int sum = 0;
    scanf("%d", &n);

    int terms = (n - 1) / 3;
    sum += ((terms) * (6 + (terms - 1) * 3)) / 2;      terms = (n - 1) / 5;
    sum += ((terms) * (10 + (terms - 1) * 5)) / 2;
    terms = (n - 1) / 15;
    sum -= ((terms) * (30 + (terms - 1) * 15)) / 2;

    printf("%d\n", sum);
}
#include <stdio.h>


int main()
{
    int n = 0;
    int sum = 0;
    int num = 0;
    scanf("%d", &n);

    while (1)
    {
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
    }

    printf("%d\n", sum);
    return 0;
}

#include <stdio.h>


int main()
{
    int t;
    printf("Enter number of times you want to try");
    scanf("%d", &t);
    while (t--)
    {
        unsigned long long N, p = 0, sum = 0;
        printf("Enter the value of N ");

        scanf("%lld", &N);          for (int i = 0; i < N; i++)
        {
            if (i % 3 == 0 || i % 5 == 0)
            {
                sum = sum + i;
            }
        }
        printf("%lld\n", sum);                                      }
    return 0;
}

#include <math.h>
#include <stdio.h>
#include <stdlib.h>


char is_prime(unsigned long n)
{
    for (unsigned long i = 2; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            return 0;

    return 1;
}


unsigned long long sum_of_primes(unsigned long N)
{
    unsigned long long sum = 2;

    for (long i = 3; i < N; i += 2) 
        if (is_prime(i))
            sum += i;

    return sum;
}


int main(int argc, char *argv[])
{
    unsigned long n = 100;

    if (argc == 2)         
        n = atol(argv[1]); 

    printf("%ld: %llu\n", n, sum_of_primes(n));

    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>


int main(int argc, char *argv[])
{
    long n = 100;
    long long sum = 0;
    char *sieve = NULL;

    if (argc == 2)         
        n = atol(argv[1]); 

    
    sieve = calloc(n, sizeof(*sieve));
    if (!sieve)
    {
        perror("Unable to allocate memory!");
        return -1;
    }

    
    for (long i = 2; i < sqrtl(n); i++)
    {
        
        if (!sieve[i])
        {
            for (long j = i * i; j < n + 1; j += i)
            {
                sieve[j] = 1;
            }
            sum += i;
        }
    }

    for (long i = sqrtl(n) + 1; i < n; i++)
        if (!sieve[i])
            sum += i;

    free(sieve);

    printf("%ld: %lld\n", n, sum);

    return 0;
}

#include <math.h>
#include <stdio.h>
#include <stdlib.h>


long count_divisors(long long n)
{
    long num_divisors = 0;

    for (long long i = 1; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            num_divisors += 2;
        else if (i * i == n)
            num_divisors += 1;

    return num_divisors;
}


int main(int argc, char **argv)
{
    int MAX_DIVISORS = 500;
    long i = 1, num_divisors;
    long long triangle_number = 1;

    if (argc == 2)
        MAX_DIVISORS = atoi(argv[1]);

    while (1)
    {
        i++;
        triangle_number += i;
        num_divisors = count_divisors(triangle_number);
        if (num_divisors > MAX_DIVISORS)
            break;
    }

    printf("First Triangle number with more than %d divisors: %lld\n",
           MAX_DIVISORS, triangle_number);

    return 0;
}

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int get_number(FILE *fp, char *buffer, uint8_t *out_int)
{
    long l = fscanf(fp, "%s\n", buffer);
    if (!l)
    {
        perror("Error reading line.");
        return -1;
    }
    
    long L = strlen(buffer);

    for (int i = 0; i < L; i++)
    {
        if (buffer[i] < 0x30 || buffer[i] > 0x39)
        {
            perror("found inavlid character in the number!");
            return -1;
        }
        else
        {
            out_int[L - i - 1] = buffer[i] - 0x30;
        }
    }

    return 0;
}


int add_numbers(uint8_t *a, uint8_t *b, uint8_t N)
{
    int carry = 0;
    uint8_t *c = b; 

    for (int i = 0; i < N; i++)
    {
                c[i] = carry + a[i] + b[i];          if (c[i] > 9)                
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
            }

    for (int i = N; i < N + 10; i++)
    {
        if (carry == 0)
        {
            break;
        }
                c[i] = carry + c[i];
        if (c[i] > 9)
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
            }
    return 0;
}


int print_number(uint8_t *number, uint8_t N, int8_t num_digits_to_print)
{
    uint8_t start_pos = N - 1;
    uint8_t end_pos;

    
    while (number[start_pos] == 0) start_pos--;

    
    if (num_digits_to_print < 0)
    {
        end_pos = 0;
    }
    else if (num_digits_to_print <= start_pos)
    {
        end_pos = start_pos - num_digits_to_print + 1;
    }
    else
    {
        fprintf(stderr, "invalid number of digits argumet!\n");
        return -1;
    }

    for (int i = start_pos; i >= end_pos; i--) putchar(number[i] + 0x30);

    putchar('\n');

    return 0;
}


int main(void)
{
    
    const int N = 10;
    
    const int N2 = N + 10;

        char *txt_buffer =
        (char *)calloc(N + 5, sizeof(char)); 
    uint8_t *number = (uint8_t *)calloc(
        N, sizeof(uint8_t)); 
    uint8_t *sum = (uint8_t *)calloc(
        N2, sizeof(uint8_t)); 

    FILE *fp = fopen("num.txt", "rt"); 
    if (!fp)
    {
        perror("Unable to open file 'num.txt'.");
        free(txt_buffer);
        free(sum);
        free(number);
        return -1;
    }

    int count = 0;
    get_number(fp, txt_buffer, sum); 
    do
    {
        count++;
        if (get_number(fp, txt_buffer, number) != 0)
        {
            break;
        }
        add_numbers(number, sum, N);
    } while (!feof(fp));

    printf("\nSum   : ");
    print_number(sum, N2, -1);

    printf("first 10 digits: \t");
    print_number(sum, N2, 10);

    fclose(fp); 
    free(txt_buffer);
    free(sum);
    free(number);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#ifdef _OPENMP
#include <omp.h>
#endif


long long collatz(long long start_num)
{
    long long length = 1;

    while (start_num != 1) 
    {
        if (start_num & 0x01) 
            start_num = 3 * start_num + 1;
        else
            start_num >>= 1; 
        length++;
    }

    return length;
}


int main(int argc, char **argv)
{
    long long max_len = 0, max_len_num = 0;
    long long MAX_NUM = 1000000;

    if (argc ==
        2) 
    {
        MAX_NUM = atoll(argv[1]);
        printf("Maximum number: %lld\n", MAX_NUM);
    }

    long long i;
#ifdef _OPENMP
#pragma omp parallel for shared(max_len, max_len_num) schedule(guided)
#endif
    for (i = 1; i < MAX_NUM; i++)
    {
        long long L = collatz(i);
        if (L > max_len)
        {
            max_len = L;     
            max_len_num = i; 
        }

#if defined(_OPENMP) && defined(DEBUG)
        printf("Thread: %2d\t %3lld: \t%5lld\n", omp_get_thread_num(), i, L);
#elif defined(DEBUG)
        printf("%3lld: \t%5lld\n", i, L);
#endif
    }

    printf("Start: %3lld: \tLength: %5lld\n", max_len_num, max_len);

    return 0;
}

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>


unsigned long long number_of_paths(int N)
{
    unsigned long long path = 1;
    for (int i = 0; i < N; i++)
    {
        path *= (N << 1) - i;
        path /= i + 1;
    }

    return path;
}


int main(int argc, char **argv)
{
    int N = 20;

    if (argc == 2)
        N = atoi(argv[1]);

    printf("Number of ways to traverse diagonal of %dx%d grid = %llu\n", N, N,
           number_of_paths(N));

    return 0;
}

#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>


int main(int argc, char **argv)
{
    const double tmp = log(10) / log(2); 
    unsigned long MAX_NUM_DIGITS;
    uint8_t *digits =
        NULL; 
    int N = 1000, sum = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    MAX_NUM_DIGITS = (N + tmp) / tmp;

    digits = calloc(MAX_NUM_DIGITS, sizeof(uint8_t));
    digits[0] = 1;

    if (!digits)
    {
        perror("Unable to allocate memory!");
        return -1;
    }

    for (int i = 0; i < N; i++)
    {
        int carry = 0;
        for (int j = 0; j < MAX_NUM_DIGITS; j++)
        {
            digits[j] = (digits[j] << 1) + carry; 
                        if (digits[j] > 9)
            {
                carry = 1;
                digits[j] -= 10;
            }
            else
                carry = 0;
            
            
            if (i == N - 1)
                sum += digits[j];
        }
    }

    printf("2^%d = ", N);
    for (int i = MAX_NUM_DIGITS - 1; i >= 0; i--) putchar(digits[i] + 0x30);
    printf("\n\t Sum: %d\t Num. digits: %lu\n", sum, MAX_NUM_DIGITS);

    free(digits);
    return 0;
}

#include <stdio.h>


char get_month_days(short month)
{
    if (month == 1) 
        return 28;
    else if (month <= 6) 
    {
        if (month & 0x01)
            return 30;
        else
            return 31;
    }

    
    if (month & 0x01)
        return 31;

    return 30;
}


char is_leap_year(short year)
{
    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)))
        return 1;

    return 0;
}

#ifdef DEBUG

const char *day_string(int day)
{
    switch (day)
    {
    case 0:
        return "Sunday";
    case 1:
        return "Monday";
    case 2:
        return "Tuesday";
    case 3:
        return "Wednesday";
    case 4:
        return "Thursday";
    case 5:
        return "Friday";
    case 6:
        return "Saturday";
    default:
        return "Shouldn't see this!";
    }
}
#endif


int main(int argc, char **argv)
{
    int count_sundays = 0;
    const short start_year = 1901;
    const short end_year = 2000;

    
    char start_day = 2;

    for (int year = start_year; year <= end_year; year++)
    {
        char is_leap = is_leap_year(year);
        for (char month = 0; month < 12; month++)
        {
            
            if (year == end_year && month == 11)
                continue;

            int days = get_month_days(month);

            if (is_leap && month == 1) 
                days++;

#ifdef DEBUG
            if (year == end_year)
            {
                printf("Year: %d\t Month: %d\t Days: %d\t First of day: %s\n",
                       year, month, days, day_string(start_day));
            }
#endif

            
            start_day = ((days % 7) + start_day) % 7;

            
            if (start_day == 0)
                count_sundays++;
        }
    }

    printf(
        "Total number of Sundays that happened on the 1st of a month in the "
        "last century: %d\n",
        count_sundays);

    return 0;
}

#include <stdio.h>


int main()
{
    int n = 0;
    int sum = 0;
    int i = 1;
    int j = 2;
    int temp;
    scanf("%d", &n);

    while (j <= n)
    {
        if ((j & 1) == 0)              sum += j;
        temp = i;
        i = j;
        j = temp + i;
    }

    printf("%d\n", sum);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


typedef struct _big_int
{
    char value;                  
    struct _big_int *next_digit; 
    struct _big_int *prev_digit; 
} big_int;

#ifdef DEBUG

void print_digit(const big_int *my_int)
{
    printf("\tValue : %d\n\tNext : %p\n\tPrev : %p\n", my_int->value,
           my_int->next_digit, my_int->prev_digit);
}
#endif


big_int *add_digit(big_int *digit, char value)
{
    if (digit == NULL)
    {
        digit = (big_int *)malloc(sizeof(big_int));
        if (!digit)
        {
            perror("Unable to allocate memory!");
            return NULL;
        }
        digit->value = value;
        digit->next_digit = NULL;
        digit->prev_digit = NULL;

        return digit;
    }

    if (digit->next_digit)
    {
        digit->next_digit->value = value;
        return digit->next_digit;
    }

    digit->next_digit = (big_int *)malloc(sizeof(big_int));
    if (digit->next_digit == NULL)
    {
        perror("Unable to allocate memory!");
        return NULL;
    }
    digit->next_digit->value = value;
    digit->next_digit->next_digit = NULL;
    digit->next_digit->prev_digit = digit;
    return digit->next_digit;
}


char remove_digits(big_int *digit, int N)
{
    if (digit == NULL)
        return 0;

    if (digit->next_digit == NULL)
    {
        free(digit);
        digit = NULL;
        return 0;
    }

    if (N > 0)
        return remove_digits(digit->next_digit, N - 1);

    return remove_digits(digit->next_digit, 0);
}


int main(int argc, char **argv)
{
    unsigned int N = 5;
    big_int *ptr = add_digit(NULL, 1); 
    const big_int *ptr0 = ptr;         
    unsigned long sum_digits = 0;
    unsigned long num_digits = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    clock_t start_time = clock();

    for (unsigned int i = 1; i <= N; i++)
    {
        int carry = 0;
#ifdef DEBUG
        printf("%3d: ", i);
#endif
        ptr = (big_int *)ptr0; 
        while (ptr)
        {
#ifdef DEBUG
            printf("%p\t", ptr);
#endif
            unsigned int tmp = ptr->value * i + carry;
            if (tmp >= 10)
            {
                div_t tmp2 = div(tmp, 10);
                carry = tmp2.quot;
                tmp = tmp2.rem;
            }
            else
                carry = 0;

            if (carry > 0 && ptr->next_digit == NULL)
                add_digit(ptr, 0);

            ptr->value = tmp;

            if (i == N)
                
                sum_digits += tmp;

            if (ptr->next_digit)
                
                ptr = ptr->next_digit;
            else
                
                break;
        }
#ifdef DEBUG
        printf("\n");
#endif
    }

    clock_t end_time = clock();

#ifdef DEBUG
    printf("ptr = %p\n", ptr);
    printf("%d! = ", N);
#endif

    
                    do
    {
        putchar(ptr->value + 0x30); 
        ptr = ptr->prev_digit;
        num_digits++;
    } while (ptr); 

    printf("\nTime taken: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf(
        "Digit Sum = %lu\tNumber of digits = %lu\tStorage space = %.3gkb\t \n",
        sum_digits, num_digits, num_digits * sizeof(big_int) / 1024.0);

    remove_digits((big_int *)ptr0, -1);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


unsigned long sum_of_divisors(unsigned int N)
{
    unsigned long sum = 1 + N; 
    
    for (unsigned int i = 2; i * i < N; i++)
    {
        if ((N % i) != 0)
            
            continue;

                        
        sum += i + (N / i);
    }
                return sum;
}


int main(int argc, char **argv)
{
    unsigned long sum = 0;
    unsigned int MAX_N = 500;
    if (argc == 2)
        MAX_N = atoi(argv[1]);

    
    char *flags = (char *)calloc(MAX_N, sizeof(char));

    clock_t start_time = clock();
    int i;
    
    for (i = 10; i < MAX_N; i++)
    {
        if (flags[i] != 0)
            
            continue;

        unsigned int b = sum_of_divisors(i);
        if (b >= MAX_N)
            flags[i] = -1;
        else if (flags[b] == -1)
            continue;

        unsigned int c = sum_of_divisors(b);
        if (c == i && b != i)
        {
            
            flags[b] = 1;
            flags[i] = 1;
            sum += b + i;
#ifdef DEBUG
            printf("Amicable: %4d : %4d\n", i, b);
#endif
        }
        else
        {
            flags[i] = -1;
            if (b < MAX_N)
                flags[b] = -1;
        }
    }

    clock_t end_time = clock();

    printf("\nTime taken: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf("Sum of all numbers = %lu\n", sum);

    free(flags);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MAX_NAMES 6000  
#define MAX_NAME_LEN 20 


void shell_sort(char data[][MAX_NAME_LEN], int LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    int i, j, g;

    for (g = 0; g < gap_len; g++)
    {
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {
            char tmp_buffer[MAX_NAME_LEN];
            strcpy(tmp_buffer, data[i]);

            for (j = i; j >= gap && strcmp(data[j - gap], tmp_buffer) > 0;
                 j -= gap)
                strcpy(data[j], data[j - gap]);
            strcpy(data[j], tmp_buffer);
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}


void lazy_sort(char data[][MAX_NAME_LEN], int LEN)
{
    int i, j;
    for (i = 0; i < LEN; i++)
    {
        for (j = i + 1; j < LEN; j++)
        {
            if (strcmp(data[i], data[j]) > 0)
            {
                char tmp_buffer[MAX_NAME_LEN];
                strcpy(tmp_buffer, data[i]);
                strcpy(data[i], data[j]);
                strcpy(data[j], tmp_buffer);
            }
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}


int main(int argc, char **argv)
{
    unsigned long COUNT = 0;
    char *fname = "names.txt";
    char names[MAX_NAMES][MAX_NAME_LEN];
    short method = 0; 

    if (argc == 2)
        method = atoi(argv[1]);

    FILE *fp = fopen(fname, "rt");
    if (!fp)
    {
        perror("Unable to open file");
        return -1;
    }

    
    do
    {
        int ret = fscanf(fp, "\"%[^\",]\",", names[COUNT++]);
        if (ret <= 0)
            continue;
            } while (!feof(fp));
    fclose(fp);

    printf("\nTotal number of names: %lu\n", COUNT);

    if (method == 0)
    {
        clock_t start_time = clock();
        shell_sort(names, COUNT);
        clock_t end_time = clock();
        printf("\nShell sort: %.4g millisecond\n",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }
    else if (method == 1)
    {
        clock_t start_time = clock();
        lazy_sort(names, COUNT);
        clock_t end_time = clock();
        printf("\nLazy sort: %.4g millisecond\n",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }

    long sum_score = 0;
    clock_t start_time = clock();
    int i;

#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum_score)
#endif
#ifdef DEBUG
    for (i = 935; i < 940; i++)
#else
    for (i = 0; i < COUNT; i++)
#endif
    {
        long score = 0;
        
        for (int j = 0; names[i][j] != '\0'; j++)
            score += names[i][j] - 'A' +
                     1; 
        sum_score += score * (i + 1);
#ifdef DEBUG
        printf("Name: %s\tScore: %u x %u = %lu\n", names[i], score, i + 1,
               (unsigned long)score * (i + 1));
#endif
    }
    clock_t end_time = clock();
    printf("Scoring time: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);

    printf("Total Score = %lu\n", sum_score);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif


char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
                return ret;
}


unsigned long is_abundant(unsigned long N)
{
    return get_perfect_number(N) == 1 ? 1 : 0;
}


unsigned long get_next_abundant(unsigned long N)
{
    unsigned long i;
    for (i = N + 1; !is_abundant(i); i++)
    {
        ;
    }
    return i;
}


char is_sum_of_abundant(unsigned long N)
{
    
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf("\t%4lu + %4lu = %4lu\n", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}


int main(int argc, char **argv)
{
    unsigned long MAX_N = 28123; 

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

#ifdef _OPENMP
    printf("Using OpenMP parallleization with %d threads\n",
           omp_get_max_threads());
#else
    printf("Not using parallleization!\n");
#endif

    double total_duration = 0.f;
    long i;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : sum) schedule(runtime)
#endif
    for (i = 1; i <= MAX_N; i++)
    {
        clock_t start_time = clock();
        if (!is_sum_of_abundant(i))
        {
            sum += i;
        }
        clock_t end_time = clock();
        total_duration += (double)(end_time - start_time) / CLOCKS_PER_SEC;

        printf("... %5lu: %8lu\r", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

    printf("Time taken: %.4g s\n", total_duration);
    printf(
        "Sum of numbers that cannot be represented as sum of two abundant "
        "numbers : %lu\n",
        sum);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif


char *abundant_flags = NULL;


char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
#ifdef DEBUG
    printf("%5lu: %5lu : %d\n", N, sum, ret);
#endif
    return ret;
}


char is_abundant(unsigned long N)
{
        return abundant_flags[N >> 3] & (1 << (N & 7))
               ? 1
               : 0; 
}


unsigned long get_next_abundant(unsigned long N)
{
    unsigned long i;
    
    for (i = N + 1; !is_abundant(i); ++i)
    {
        ;
    }
    return i;
}


char is_sum_of_abundant(unsigned long N)
{
    
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf("\t%4lu + %4lu = %4lu\n", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}


int main(int argc, char **argv)
{
    long MAX_N = 28123; 

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

    
    abundant_flags = (char *)calloc(MAX_N >> 3, 1);
    if (!abundant_flags)
    {
        perror("Unable to allocate memoey!");
        return -1;
    }

#ifdef _OPENMP
    printf("Using OpenMP parallleization with %d threads\n",
           omp_get_max_threads());
#else
    printf("Not using parallleization!\n");
#endif

    clock_t start_time = clock();

    
    long N;
#ifdef _OPENMP
#pragma omp for schedule(runtime)
#endif
    for (N = 1; N <= MAX_N; N++)
    {
        char ret = get_perfect_number(N);
        if (ret == 1)
        {
                        int byte_offset = N & 7, index = N >> 3;
#ifdef _OPENMP
#pragma omp critical
#endif
            abundant_flags[index] |= ret << byte_offset;
        }
                    }

    clock_t end_time = clock();
    double t1 = 1e3 * (end_time - start_time) / CLOCKS_PER_SEC;
    printf("Time taken to get abundant numbers: %.4g ms\n", t1);

    clock_t t2 = 0;
    long i;
#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum)
#endif
    for (i = 1; i < MAX_N; i++)
    {
        clock_t start_time1 = clock();
        if (!is_sum_of_abundant(i))
        {
                                                sum += i;
        }
        clock_t end_time1 = clock();
#ifdef _OPENMP
#pragma omp critical
#endif
        t2 += end_time1 - start_time1;

        printf("... %5lu: %8lu\r", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

#ifdef DEBUG
    putchar('\n');
#endif
    double t22 = 1e3 * t2 / CLOCKS_PER_SEC;
    printf("Time taken for final sum: %.4g ms\nTotal Time taken: %.4g ms\n",
           t22, t1 + t22);
    printf("Memory used: %lu bytes\n", MAX_N >> 3);
    printf(
        "Sum of numbers that cannot be represented as sum of two abundant "
        "numbers : %lu\n",
        sum);

    free(abundant_flags);

    return 0;
}

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_DIGITS 1000 


unsigned int add_numbers(unsigned char *a, unsigned char *b, unsigned char *c,
                         int N)
{
    unsigned char carry = 0;
    unsigned int i;

    for (i = 0; i < N; i++)
    {
                c[i] = carry + a[i] + b[i];
        if (c[i] > 9) 
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
            }

    while (carry != 0)
    {
                        c[i] = carry + c[i];
        if (c[i] > 9)
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
                i++;
    }
    return i;
}


int print_number(unsigned char *number, int N)
{
    int start_pos = N - 1;

    
    while (number[start_pos] == 0) start_pos--;

    for (int i = start_pos; i >= 0; i--) putchar(number[i] + 0x30);

    return 0;
}


unsigned int get_digits(unsigned char *number)
{
    unsigned int digits = MAX_DIGITS;
    while (number[digits] == 0) digits--;
    return digits;
}


int main(int argc, char *argv[])
{
    unsigned char
        fn[MAX_DIGITS + 1]; 
    unsigned char fn1[MAX_DIGITS + 1];
    unsigned char sum[MAX_DIGITS + 1];

    memset(fn, 0, MAX_DIGITS);
    memset(fn1, 0, MAX_DIGITS);
    memset(sum, 0, MAX_DIGITS);

    fn[0] = 1;
    fn1[1] = 1;

    unsigned int index = 1, digit_count = 1;

    clock_t start_time = clock();
    do
    {
        digit_count = add_numbers(fn, fn1, sum, digit_count);
        
                        
        if (digit_count == MAX_DIGITS)
        {
            break;
        }
        memcpy(fn, fn1, MAX_DIGITS);
        memcpy(fn1, sum, MAX_DIGITS);
        index++;
    } while (digit_count < MAX_DIGITS);
    clock_t end_time = clock();

    printf("Time taken: %.4g ms\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf("The nth term for %d digits: %u \n", MAX_DIGITS, index--);
    print_number(sum, digit_count);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MAX_DENO 2000 
#define MAX_LEN \
    (MAX_DENO + 10) 


int compare(const void *a, const void *b)
{
    return (*(unsigned short *)a - *(unsigned short *)b);
}


int main(int argc, char *argv[])
{
    unsigned short max_digits = 0, max_idx_number = 0;

    clock_t start_time = clock();
    short deno;
#ifdef _OPENMP
#pragma omp for
#endif
    for (deno = 2; deno < MAX_DENO; deno++)
    {
        unsigned short remainders[MAX_LEN];
        unsigned short rem = 1, *rem_ptr = remainders;
        memset(remainders, (unsigned short)-1,
               MAX_LEN * sizeof(unsigned short));
                        unsigned short index = 0, num_digits;

        while (rem != 0)
        {
            rem = (rem * 10) % deno;
            if (rem == 0)
            {
                index = 0;
                break;
            }
            rem_ptr = (unsigned short *)bsearch(
                &rem, remainders, MAX_LEN, sizeof(unsigned short), compare);
                                    if (rem_ptr != NULL)
                break;
            remainders[index] = rem;
            rem_ptr = remainders;
            index++;
        }

        num_digits = index - (rem_ptr - remainders);
                #ifdef _OPENMP
#pragma omp critical
        {
#endif
            if (num_digits > max_digits)
            {
                max_digits = num_digits;
                max_idx_number = deno;
                            }
#ifdef _OPENMP
        }
#endif
    }
    clock_t end_time = clock();

    printf("Time taken: %.4g ms\n",
           1e3 * (double)(end_time - start_time) / CLOCKS_PER_SEC);
    printf("Maximum digits: %hu\t Denominator: %hu\n", max_digits,
           max_idx_number);

    return 0;
}

#include <math.h>
#include <stdio.h>


char isprime(int no)
{
    int sq;

    if (no == 2)
    {
        return 1;
    }
    else if (no % 2 == 0)
    {
        return 0;
    }
    sq = ((int)(sqrt(no))) + 1;
    for (int i = 3; i < sq; i += 2)
    {
        if (no % i == 0)
        {
            return 0;
        }
    }
    return 1;
}


int main()
{
    int maxNumber = 0;
    int n = 0;
    int n1;
    scanf("%d", &n);
    if (isprime(n) == 1)
        printf("%d", n);
    else
    {
        while (n % 2 == 0)
        {
            n = n / 2;
        }
        if (isprime(n) == 1)
        {
            printf("%d\n", n);
        }
        else
        {
            n1 = ((int)(sqrt(n))) + 1;
            for (int i = 3; i < n1; i += 2)
            {
                if (n % i == 0)
                {
                    if (isprime((int)(n / i)) == 1)
                    {
                        maxNumber = n / i;
                        break;
                    }
                    else if (isprime(i) == 1)
                    {
                        maxNumber = i;
                    }
                }
            }
            printf("%d\n", maxNumber);
        }
    }
    return 0;
}
#include <stdio.h>


int main()
{
    int n = 0;
    scanf("%d", &n);
    int prime = 1;
    int i = 2;
    while (i * i <= n)
    {
        while (n % i == 0)
        {
            prime = i;
            n /= i;
        }
        i += 1;
    }
    if (n > 1)
        prime = n;
    printf("%d\n", prime);
    return 0;
}
#include <stdio.h>


int is_palindromic(unsigned int n)
{
    unsigned int reversed = 0, t = n;

    while (t > 0)
    {
        reversed = 10 * reversed + (t % 10);
        t /= 10;
    }
    return reversed == n;
}


int main(void)
{
    unsigned int i, j, max = 0;
    for (i = 100; i <= 999; i++)
    {
        for (j = 100; j <= 999; j++)
        {
            unsigned int p = i * j;
            if (is_palindromic(p) && p > max)
            {
                max = p;
            }
        }
    }
    printf("%u\n", max);
    return 0;
}

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MOD_LIMIT (uint64_t)1e9 
#define MAX_LENGTH 5000         


char is_in(uint64_t N, uint64_t *D, uint64_t L)
{
    uint64_t i;
    for (i = 0; i < L; i++)
    {
        if (D[i] == N)
        {
            return 1;
        }
    }
    return 0;
}


uint64_t get_divisors(uint64_t N, uint64_t *D)
{
    uint64_t q, r;
    int64_t i, num = 0;

    if (N == 1)
    {
        D[0] = 1;
        return 1;
    }

            for (i = 1; i * i <= N + 1; i++)
    {
        r = N % i;  
                if (r == 0)
        {
            q = N / i;
            if (!is_in(i, D, num))              {
                D[num] = i;
                num++;
            }
            if (!is_in(q, D, num))              {
                D[num] = q;
                num++;
            }
        }

        if (num == MAX_LENGTH)
        {              D = (uint64_t *)realloc(D, MAX_LENGTH * sizeof(uint64_t) << 1);
        }
    }
    return num;
}


uint64_t sigma2(uint64_t N)
{
    uint64_t sum = 0, L;
    int64_t i;
    uint64_t *D = (uint64_t *)malloc(MAX_LENGTH * sizeof(uint64_t));

    L = get_divisors(N, D);
    for (i = 1; i < L; i++)
    {
        uint64_t DD = (D[i] * D[i]) % MOD_LIMIT;
        sum += DD;
    }

    free(D);
    return sum % MOD_LIMIT;
}


uint64_t sigma(uint64_t N)
{
    uint64_t s, sum = 0;
    int64_t i;

#ifdef _OPENMP
#pragma omp parallel for reduction(+ : sum)
#endif
    for (i = 0; i <= N; i++)
    {
        s = sigma2(i);
        sum += s;
    }
    return sum % MOD_LIMIT;
}


int main(int argc, char **argv)
{
    uint64_t N = 1000;

    if (argc == 2)
    {
        N = strtoll(argv[1], NULL, 10);
    }
    else if (argc > 2)
    {
        fprintf(stderr, "Wrong number of input arguments!\n");
        printf("Usage:\t ./sol1.c [N=1000]");
        return -1;
    }

    clock_t start_time = clock();
    uint64_t result = sigma(N);
    double dtime = clock() - start_time;

    printf("N = %" PRIu64 "\nSum: %" PRIu64 "\n", N, result);
    printf("Time taken: %.4gms\n", dtime * 1e3 / CLOCKS_PER_SEC);

    return 0;
}

#include <stdio.h>


unsigned long gcd(unsigned long a, unsigned long b)
{
    unsigned long r;
    if (a > b)
    {
        unsigned long t = a;
        a = b;
        b = t;
    }
    while ((r = (a % b)))
    {
        a = b;
        b = r;
    }
    return b;
}


unsigned long lcm(unsigned long a, unsigned long b)
{
    unsigned long long p = (unsigned long long)a * b;
    return p / gcd(a, b);
}


int main(void)
{
    unsigned long ans = 1;
    unsigned long i;
    for (i = 1; i <= 20; i++)
    {
        ans = lcm(ans, i);
    }
    printf("%lu\n", ans);
    return 0;
}

#include <stdio.h>


int main(void)
{
    unsigned s1 = 0, s2 = 0, i;
    for (i = 1; i <= 100; i++)
    {
        s1 += i * i;
        s2 += i;
    }
    unsigned ans = s2 * s2 - s1;
    printf("%u\n", ans);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>


int main(void)
{
    char *sieve;
    size_t i;
    unsigned count = 0;
    size_t n = 1000000;
    const unsigned target = 10001;

    sieve = (char *)calloc(n, sizeof(char));
    for (i = 2; i < n; i++)
    {
        if (!sieve[i])
        {
            size_t j;
            count++;
            if (count == target)
            {
                printf("%lu\n", i);
                break;
            }
            for (j = i * 2; j < n; j += i)
            {
                sieve[j] = 1;
            }
        }
    }
    free(sieve);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>


long long int get_product(FILE *fp, long start_pos, int num_digits)
{
    char ch = ' '; 
    unsigned char num = 0;  
    long long int prod = 1; 
    int count =
        0; 

    
    for (int i = 0; i < num_digits; i++, count++)
    {
        
        ch = getc(fp);

        
        if (ch < 0x30 || ch > 0x39)
        {
            if (ch == EOF)
                return 0;
            i--;
            continue;
        }

        num = ch - 0x30; 
        if (num == 0)
        {
            
            
            return 0;
        }

        prod *= num; 
    }

    
    fseek(fp, -count + 1, SEEK_CUR);

    return prod;
}


int main(int argc, char *argv[])
{
    int position = 0;
    int num_digits = 4;
    long long int prod, max_prod = 0;

    
    if (argc == 2)
        num_digits = atoi(argv[1]);

    
    FILE *fp = fopen("digits.txt", "rt");
    if (!fp)
    {
        perror("Unable to open file");
        return -1;
    }

    
    do
    {
        
        prod = get_product(fp, ftell(fp), num_digits);

        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - 1;
        }
    } while (!feof(fp)); 

    printf("Maximum product: %lld\t Location: %d^th position\n\t", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); 
    
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); 
        
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf("%c x ", ch);
        else
            printf("%c = %lld\n", ch, max_prod);
    }

    fclose(fp); 

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h> 


int main(int argc, char *argv[])
{
    int position = 0, num_bad_chars = 0;
    int num_digits = 4;
    char ch;
    unsigned char num, num_prev;
    unsigned char *buffer = NULL;
    long long int prod = 1, max_prod = 0;

    
    if (argc == 2)
        num_digits = atoi(argv[1]);

    
    buffer = calloc(num_digits, sizeof(unsigned char));
    if (!buffer)
    {
        perror("Unable to allocate memory for buffer");
        return -1;
    }

    
    FILE *fp = fopen("digits.txt", "rt");
    if (!fp)
    {
        perror("Unable to open file");
        free(buffer); 
        return -1;
    }

    
    do
    {
        
        ch = getc(fp);

        
        if (ch < 0x30 || ch > 0x39)
        {
            num_bad_chars++; 
            continue;
        }
        else if (num_bad_chars > 0)
            num_bad_chars--;

        num = ch - 0x30;      
        num_prev = buffer[0]; 

        
        memmove(buffer, buffer + 1, num_digits - 1);
        

        buffer[num_digits - 1] = num; 

        if (num_prev != 0)
        {
            
            prod /= num_prev; 
            prod *= num;
        }
        else
        {
            prod = 1;
            for (int i = 0; i < num_digits; i++)
            {
                if (buffer[i] == 0)
                {
                    prod = 0;
                    break; 
                }
                prod *= buffer[i];
            }
        }

        
        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - num_bad_chars - num_digits - 1;
        }
    } while (!feof(fp)); 

    printf("Maximum product: %lld\t Location: %d^th position\n\t", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); 
    
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); 
        
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf("%c x ", ch);
        else
            printf("%c = %lld\n", ch, max_prod);
    }

    fclose(fp);   
    free(buffer); 

    return 0;
}

#include <stdio.h>


int main(void)
{
    for (int a = 1; a < 300; a++)
        for (int b = a + 1; b < 400; b++)
            for (int c = b + 1; c < 500; c++)
            {
                if (a * a + b * b == c * c)
                    if (a + b + c == 1000)
                    {
                        printf("%d x %d x %d = %ld\n", a, b, c,
                               (long int)a * b * c);
                        return 0;
                    }
            }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>


int main(void)
{
    int N = 1000;

    for (int a = 1; a < 300; a++)
    {
        long tmp1 = N * N - 2 * a * N;
        long tmp2 = 2 * (N - a);
        div_t tmp3 = div(tmp1, tmp2);
        int b = tmp3.quot;
        int c = N - a - b;

        if (a * a + b * b == c * c)
        {
            printf("%d x %d x %d = %ld\n", a, b, c, (long int)a * b * c);
            return 0;
        }
    }

    return 0;
}#include <stdio.h>
#include <string.h>

#define NUM_OF_CHARS 256

int max(int a, int b) { return (a > b) ? a : b; }

void computeArray(char *pattern, int size, int arr[NUM_OF_CHARS])
{
    int i;

    for (i = 0; i < NUM_OF_CHARS; i++) arr[i] = -1;
    
    for (i = 0; i < size; i++) arr[(int)pattern[i]] = i;
}

void boyer_moore_search(char *str, char *pattern)
{
    int n = strlen(str);
    int m = strlen(pattern);
    int shift = 0;
    int arr[NUM_OF_CHARS];

    computeArray(pattern, m, arr);
    while (shift <= (n - m))
    {
        int j = m - 1;
        while (j >= 0 && pattern[j] == str[shift + j]) j--;
        if (j < 0)
        {
            printf("--Pattern is found at: %d\n", shift);
            shift += (shift + m < n) ? m - arr[str[shift + m]] : 1;
        }
        else
        {
            shift += max(1, j - arr[str[shift + j]]);
        }
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; 
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    boyer_moore_search(str, pat1);
    printf("Test2: search pattern %s\n", pat2);
    boyer_moore_search(str, pat2);
    printf("Test3: search pattern %s\n", pat3);
    boyer_moore_search(str, pat3);
    return 0;
}
#include <stdio.h>
#include <string.h>


void naive_search(char *str, char *pattern)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);

    for (int i = 0; i <= len_str - len_pat; i++)
    {
        int j;
        for (j = 0; j < len_pat; j++)
        {
            if (str[i + j] != pattern[j])
                break;
        }
        if (j == len_pat)
            printf("--Pattern is found at: %d\n", i);
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; 
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    naive_search(str, pat1);
    printf("Test2: search pattern %s\n", pat2);
    naive_search(str, pat2);
    printf("Test3: search pattern %s\n", pat3);
    naive_search(str, pat3);
    return 0;
}
#include <stdio.h>
#include <string.h>


void rabin_karp_search(char *str, char *pattern, int d, int q)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);
    int i, h = 1;
    int hash_s = 0; 
    int hash_p = 0; 

    
    for (i = 0; i < len_pat - 1; i++) h = d * h % q;
    
    for (i = 0; i < len_pat; i++)
    {
        hash_p = (d * hash_p + pattern[i]) % q;
        hash_s = (d * hash_s + str[i]) % q;
    }

    for (i = 0; i <= len_str - len_pat; i++)
    {
        
        if (hash_p == hash_s)
        {
            int j;
            for (j = 0; j < len_pat; j++)
            {
                if (pattern[j] != str[i + j])
                    break;
            }
            if (len_pat == j)
                printf("--Pattern is found at: %d\n", i);
        }
        
        hash_s = (d * (hash_s - str[i] * h) + str[i + len_pat]) % q;
        
        if (hash_s < 0)
            hash_s = hash_s + q;
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; 
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    rabin_karp_search(str, pat1, 256, 29);
    printf("Test2: search pattern %s\n", pat2);
    rabin_karp_search(str, pat2, 256, 29);
    printf("Test3: search pattern %s\n", pat3);
    rabin_karp_search(str, pat3, 256, 29);
    return 0;
}
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#define MAX 80
#define PORT 8080
#define SA struct sockaddr
void func(int sockfd)
{
    char buff[MAX];
    int n;
    for (;;)
    {
        bzero(buff, sizeof(buff));
        printf("Enter the string : ");
        n = 0;
        while ((buff[n++] = getchar()) != '\n')
            ;
        write(sockfd, buff, sizeof(buff));
        bzero(buff, sizeof(buff));
        read(sockfd, buff, sizeof(buff));
        printf("From Server : %s", buff);
        if ((strncmp(buff, "exit", 4)) == 0)
        {
            printf("Client Exit...\n");
            break;
        }
    }
}

int main()
{
    int sockfd, connfd;
    struct sockaddr_in servaddr, cli;

        sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully created..\n");
    bzero(&servaddr, sizeof(servaddr));

        servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    servaddr.sin_port = htons(PORT);

        if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)
    {
        printf("connection with the server failed...\n");
        exit(0);
    }
    else
        printf("connected to the server..\n");

        func(sockfd);

        close(sockfd);
}
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#define MAX 80
#define PORT 8080
#define SA struct sockaddr

void func(int sockfd)
{
    char buff[MAX];
    int n;
        for (;;)
    {
        bzero(buff, MAX);

                read(sockfd, buff, sizeof(buff));
                printf("From client: %s\t To client : ", buff);
        bzero(buff, MAX);
        n = 0;
                while ((buff[n++] = getchar()) != '\n')
            ;

                write(sockfd, buff, sizeof(buff));

                if (strncmp("exit", buff, 4) == 0)
        {
            printf("Server Exit...\n");
            break;
        }
    }
}

int main()
{
    int sockfd, connfd, len;
    struct sockaddr_in servaddr, cli;

        sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully created..\n");
    bzero(&servaddr, sizeof(servaddr));

        servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(PORT);

        if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)
    {
        printf("socket bind failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully binded..\n");

        if ((listen(sockfd, 5)) != 0)
    {
        printf("Listen failed...\n");
        exit(0);
    }
    else
        printf("Server listening..\n");
    len = sizeof(cli);

        connfd = accept(sockfd, (SA *)&cli, &len);
    if (connfd < 0)
    {
        printf("server acccept failed...\n");
        exit(0);
    }
    else
        printf("server acccept the client...\n");

        func(connfd);

        close(sockfd);
}
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define PORT 8080
#define MAXLINE 1024

int main()
{
    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from client";
    struct sockaddr_in servaddr;

        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));

        servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    servaddr.sin_addr.s_addr = INADDR_ANY;

    int n, len;

    sendto(sockfd, (const char *)hello, strlen(hello), MSG_CONFIRM,
           (const struct sockaddr *)&servaddr, sizeof(servaddr));
    printf("Hello message sent.\n");

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&servaddr, &len);
    buffer[n] = '\0';
    printf("Server : %s\n", buffer);

    close(sockfd);
    return 0;
}
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define PORT 8080
#define MAXLINE 1024

int main()
{
    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from server";
    struct sockaddr_in servaddr, cliaddr;

        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

        servaddr.sin_family = AF_INET;      servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

        if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    int len, n;
    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&cliaddr, &len);
    buffer[n] = '\0';
    printf("Client : %s\n", buffer);
    sendto(sockfd, (const char *)hello, strlen(hello), MSG_CONFIRM,
           (const struct sockaddr *)&cliaddr, len);
    printf("Hello message sent.\n");

    return 0;
}


#include <stdio.h>

int main()
{
    int remainder, number = 0, decimal_number = 0, temp = 1;
    printf("/n Enter any binary number= ");
    scanf("%d", &number);

        while (number > 0)
    {
        remainder = number % 10;
        number = number / 10;
        decimal_number += remainder * temp;
        temp = temp * 2;      }

    printf("%d\n", decimal_number);
}

#include <stdio.h>

int main()
{
    long int binary, hexa = 0, i = 1, remainder;

    printf("Enter the binary number: ");
    scanf("%ld", &binary);
    while (binary != 0)
    {
        remainder = binary % 10;
        hexa = hexa + remainder * i;
        i = i * 2;
        binary = binary / 10;
    }
    printf("THe Equivalent hexadecimal value: %lX", hexa);
    return 0;
}
#include <stdio.h>

int three_digits(int n)
{
    int r, d = 0, p = 1;

    for (int i = 0; i < 3; i++)
    {
        r = n % 10;
        d += r * p;
        p *= 10;
        n /= 10;
    }
    return d;
}

int main(void)
{
    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;

    printf("Enter the binary no: ");
    scanf("%d", &binary_num);

    while (binary_num > 0)
    {
        if (binary_num >
            111)              td = three_digits(binary_num);

        else
            td = binary_num;

        binary_num /= 1000;

        d = 0, base = 1;

                while (td > 0)
        {
            remainder = td % 10;
            td /= 10;
            d += (base * remainder);
            base *= 2;
        }

        res += d * ord;          ord *= 10;
    }

    printf("\nOctal equivalent is: %d", res);
    return 0;
}

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int c_atoi(const char *str)
{
    int i;
    int sign;
    long value;
    long prev;

    i = 0;
    sign = 1;
    value = 0;

    
    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\0')
        i++;

    
    if (str[i] == '-')
        sign = -1;
    else if (str[i] == '+')
        sign = 1;

    
    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\0')
    {
        prev = value;
        value = value * 10 + sign * (str[i] - '0');

        
        if (sign == 1 && prev > value)
            return (-1);
        else if (sign == -1 && prev < value)
            return (0);
        i++;
    }
    return (value);
}


void test_c_atoi()
{
    printf("<<<< TEST FUNCTION >>>>\n");
    assert(c_atoi("123") == atoi("123"));
    assert(c_atoi("-123") == atoi("-123"));
    assert(c_atoi("") == atoi(""));
    assert(c_atoi("-h23") == atoi("-h23"));
    assert(c_atoi("         23") == atoi("         23"));
    assert(c_atoi("999999999") == atoi("999999999"));
    printf("<<<< TEST DONE >>>>\n");
}


int main(int argc, char **argv)
{
    test_c_atoi();

    if (argc == 2)
    {
        printf("Your number + 5 is %d\n", c_atoi(argv[1]) + 5);
        return (0);
    }
    printf("wrong number of parmeters\n");
    return (1);
}
#include <stdio.h>
#include <stdlib.h>

#define MAXBITS 100

int main()
{
        int inputNumber;

        int re;

        int bits[MAXBITS];

        int j;
    int i = 0;

    printf("\t\tConverter decimal --> binary\n\n");

        printf("\nenter a positive integer number: ");
    scanf("%d", &inputNumber);

        if (inputNumber < 0)
    {
        printf("only positive integers >= 0\n");
        return 1;
    }

        while (inputNumber > 0)
    {
                re = inputNumber % 2;

                inputNumber = inputNumber / 2;

        bits[i] = re;
        i++;
    }

    printf("\n the number in binary is: ");

        for (j = i - 1; j >= 0; j--)
    {
        printf("%d", bits[j]);
    }

        if (i == 0)
    {
        printf("0");
    }

    return 0;
}

#include <stdio.h>
void decimal2Hexadecimal(long num);

int main()
{
    long decimalnum;

    printf("Enter decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Hexadecimal(decimalnum);

    return 0;
}


void decimal2Hexadecimal(long num)
{
    long decimalnum = num;
    long quotient, remainder;
    int i, j = 0;
    char hexadecimalnum[100];

    quotient = decimalnum;

    while (quotient != 0)
    {
        remainder = quotient % 16;
        if (remainder < 10)
            hexadecimalnum[j++] = 48 + remainder;

        else
            hexadecimalnum[j++] = 55 + remainder;

        quotient = quotient / 16;
    }

    
    for (i = j; i >= 0; i--)
    {
        printf("%c", hexadecimalnum[i]);
    }

    printf("\n");
}

#include <stdio.h>
void decimal2Octal(long decimalnum);

int main()
{
    long decimalnum;

    printf("Enter the decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Octal(decimalnum);

    return 0;
}


void decimal2Octal(long decimalnum)
{
    long remainder, quotient;

    int octalNumber[100], i = 1, j;
    quotient = decimalnum;

    while (quotient != 0)
    {
        octalNumber[i++] = quotient % 8;

        quotient = quotient / 8;
    }

    for (j = i - 1; j > 0; j--) printf("%d", octalNumber[j]);

    printf("\n");
}

#include <stdio.h>
int decimal_to_octal(int decimal)
{
    if ((decimal < 8) && (decimal > 0))
    {
        return decimal;
    }
    else if (decimal == 0)
    {
        return 0;
    }
    else
    {
        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);
    }
}
int main()
{
    int octalNumber, decimalNumber;
    printf("\nEnter your decimal number : ");
    scanf("%d", &decimalNumber);
    octalNumber = decimal_to_octal(decimalNumber);
    printf("\nThe octal of %d is : %d", decimalNumber, octalNumber);
    return 0;
}


#include <stdio.h>

int main()
{
#define MAX_STR_LEN 17
    char hex[MAX_STR_LEN];
    long long octal, bin, place;
    int i = 0, rem, val;

    
    printf("Enter any hexadecimal number: ");
    fgets(hex, MAX_STR_LEN, stdin);

    octal = 0ll;
    bin = 0ll;
    place = 0ll;

    
    for (i = 0; hex[i] != '\0'; i++)
    {
        bin = bin * place;

        switch (hex[i])
        {
        case '0':
            bin += 0;
            break;
        case '1':
            bin += 1;
            break;
        case '2':
            bin += 10;
            break;
        case '3':
            bin += 11;
            break;
        case '4':
            bin += 100;
            break;
        case '5':
            bin += 101;
            break;
        case '6':
            bin += 110;
            break;
        case '7':
            bin += 111;
            break;
        case '8':
            bin += 1000;
            break;
        case '9':
            bin += 1001;
            break;
        case 'a':
        case 'A':
            bin += 1010;
            break;
        case 'b':
        case 'B':
            bin += 1011;
            break;
        case 'c':
        case 'C':
            bin += 1100;
            break;
        case 'd':
        case 'D':
            bin += 1101;
            break;
        case 'e':
        case 'E':
            bin += 1110;
            break;
        case 'f':
        case 'F':
            bin += 1111;
            break;
        default:
            printf("Invalid hexadecimal input.");
        }

        place = 10000;
    }

    place = 1;

    
    while (bin > 0)
    {
        rem = bin % 1000;

        switch (rem)
        {
        case 0:
            val = 0;
            break;
        case 1:
            val = 1;
            break;
        case 10:
            val = 2;
            break;
        case 11:
            val = 3;
            break;
        case 100:
            val = 4;
            break;
        case 101:
            val = 5;
            break;
        case 110:
            val = 6;
            break;
        case 111:
            val = 7;
            break;
        }

        octal = (val * place) + octal;
        bin /= 1000;

        place *= 10;
    }

    printf("Hexadecimal number = %s\n", hex);
    printf("Octal number = %lld", octal);

    return 0;
}
#include <math.h>
#include <stdio.h>

int convertValue(int num, int i) { return num * pow(8, i); }

long long toDecimal(int octal_value)
{
    int decimal_value = 0, i = 0;

    while (octal_value)
    {
                decimal_value += convertValue(octal_value % 10, i++);

                octal_value /= 10;
    }

    return decimal_value;
}

int main()
{
    printf("Enter octal value: ");

    int octal_value;

    scanf("%d", &octal_value);

    long long result = toDecimal(octal_value);

    printf("%d in decimal is %lld\n", octal_value, result);

    return 0;
}


#include <ctype.h>
#include <stdio.h>

int main(void)
{
    int base, i, j;
    char number[100];
    unsigned long decimal = 0;

    printf("Enter the base: ");
    scanf("%d", &base);
    printf("Enter the number: ");
    scanf("%s", &number[0]);

    for (i = 0; number[i] != '\0'; i++)
    {
        if (isdigit(number[i]))
            number[i] -= '0';
        else if (isupper(number[i]))
            number[i] -= 'A' - 10;
        else if (islower(number[i]))
            number[i] -= 'a' - 10;
        else
            number[i] = base + 1;

        if (number[i] >= base)
        {
            printf("invalid number\n");
            return 0;
        }
    }

    for (j = 0; j < i; j++)
    {
        decimal *= base;
        decimal += number[j];
    }

    printf("%lu\n", decimal);
}
#include <stdio.h>
#include <stdlib.h>


struct node
{
    int data;
    struct node *next;
    struct node *pre;
} * head, *tail, *tmp;

int count;

void create();
void enque(int x);
int deque();
int peek();
int size();
int isEmpty();


int main(int argc, char const *argv[])
{
    create();
    enque(5);

    return 0;
}

void create()
{
    head = NULL;
    tail = NULL;
}


void enque(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(1 * sizeof(struct node));
        head->data = x;
        head->pre = NULL;
        tail = head;
    }
    else
    {
        tmp = (struct node *)malloc(1 * sizeof(struct node));
        tmp->data = x;
        tmp->next = tail;
        tail = tmp;
    }
}


int deque()
{
    int returnData = 0;
    if (head == NULL)
    {
        printf("ERROR: Deque from empty queue.\n");
        exit(1);
    }
    else
    {
        returnData = head->data;
        if (head->pre == NULL)
            head = NULL;
        else
            head = head->pre;
        head->next = NULL;
    }
    return returnData;
}


int size() { return count; }

#include <stdio.h>
#include <stdlib.h>


struct node
{
    int data;
    struct node *next;
    struct node *pre;
} * head, *tmp;

int count = 0;

void create();
void push(int x);
int pop();
int peek();
int size();
int isEmpty();


int main(int argc, char const *argv[])
{
    int x, y, z;

    create();
    push(4);
    x = pop();
        printf("%d.\t\tCount: %d.\tEmpty: %d.\n", x, size(), isEmpty());

    push(1);
    push(2);
    push(3);
    x = pop();
    y = pop();
        printf("%d, %d.\t\tCount: %d.\tEmpty: %d.\n", x, y, size(), isEmpty());
    pop();  
    push(5);
    push(6);
    x = peek();
    push(7);
    y = pop();
    push(8);
    z = pop();
        printf("%d, %d, %d.\tCount: %d.\tEmpty: %d.\n", x, y, z, size(), isEmpty());

    return 0;
}


void create() { head = NULL; }


void push(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(1 * sizeof(struct node));
        head->next = NULL;
        head->pre = NULL;
        head->data = x;
    }
    else
    {
        tmp = (struct node *)malloc(1 * sizeof(struct node));
        tmp->data = x;
        tmp->next = NULL;
        tmp->pre = head;
        head->next = tmp;
        head = tmp;
    }
    ++count;
}


int pop()
{
    int returnData;
    if (head == NULL)
    {
        printf("ERROR: Pop from empty stack.\n");
        exit(1);
    }
    else
    {
        returnData = head->data;

        if (head->pre == NULL)
        {
            free(head);
            head = NULL;
        }
        else
        {
            head = head->pre;
            free(head->next);
        }
    }
    --count;
    return returnData;
}


int peek()
{
    if (head != NULL)
        return head->data;
    else
    {
        printf("ERROR: Peeking from empty stack.");
        exit(1);
    }
}


int size() { return count; }


int isEmpty()
{
    if (count == 0)
        return 1;
    return 0;
}

#define _USE_MATH_DEFINES 
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


void spirograph(double *x, double *y, double l, double k, size_t N, double rot)
{
    double dt = rot * 2.f * M_PI / N;
    double t = 0.f, R = 1.f;
    const double k1 = 1.f - k;

    for (size_t dk = 0; dk < N; dk++, t += dt)
    {
        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));
        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));
    }
}


void test(void)
{
    size_t N = 500;
    double l = 0.3, k = 0.75, rot = 10.;
    char fname[50];
    snprintf(fname, 50, "spirograph_%.2f_%.2f_%.2f.csv", l, k, rot);
    FILE *fp = fopen(fname, "wt");
    if (!fp)
    {
        perror(fname);
        exit(EXIT_FAILURE);
    }

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l, k, N, rot);

    for (size_t i = 0; i < N; i++)
    {
        fprintf(fp, "%.5g, %.5g", x[i], y[i]);
        if (i < N - 1)
        {
            fputc('\n', fp);
        }
    }

    fclose(fp);

    free(x);
    free(y);
}

#ifdef USE_GLUT  #ifdef __APPLE__
#include <GLUT/glut.h>  #else
#include <GL/glut.h>
#endif

static bool paused = 0; 
static const int animation_speed = 25; 

static const double step = 0.01;   
static double l_ratio = 0.1;       
static double k_ratio = 0.1;       
static const double num_rot = 20.; 


static inline void glutBitmapString(void *font, char *string)
{
    for (char *ch = string; *ch != '\0'; ch++) glutBitmapCharacter(font, *ch);
}


void display_graph(const double *x, const double *y, size_t N, double l,
                   double k)
{
    glClearColor(1.0f, 1.0f, 1.0f,
                 0.0f);                glClear(GL_COLOR_BUFFER_BIT);  
    if (x && y)
    {
        glBegin(GL_LINES);                 glColor3f(0.f, 0.f, 1.f);          glPointSize(2.f);          
        for (size_t i = 1; i < N; i++)
        {
            glVertex2f(x[i - 1], y[i - 1]);              glVertex2f(x[i], y[i]);                  }
        glEnd();
    }
    glColor3f(0.f, 0.f, 0.f);
    char buffer[20];
    snprintf(buffer, 20, "l = %.3f", l);
    glRasterPos2f(-.85, .85);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);
    snprintf(buffer, 20, "k = %.3f", k);
    glRasterPos2f(-.85, .75);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);

    glutSwapBuffers();
}


void test2(void)
{
    const size_t N = 1000;  
    static bool direction1 = true;      static bool direction2 = true;  
    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l_ratio, k_ratio, N, num_rot);
    display_graph(x, y, N, l_ratio, k_ratio);

    free(x);      free(y);

    if (paused)
                return;

    if (direction1)      {
        if (k_ratio >= (1.f - step))              direction1 = false;               else
            k_ratio += step;
    }
    else      {
        if (k_ratio <= step)          {
            direction1 = true;  
            if (direction2)              {
                if (l_ratio >= (1.f - step))                      direction2 = false;                       else
                    l_ratio += step;
            }
            else              {
                if (l_ratio <= step)                        direction2 = true;                  else
                    l_ratio -= step;
            }
        }
        else              k_ratio -= step;
    }
}


void timer_cb(int id)
{
    glutPostRedisplay();
    glutTimerFunc(animation_speed, timer_cb, 0);
}


void keyboard_cb(unsigned char key, int x, int y)
{
    switch (key)
    {
    case ' ':                      paused = !paused;          break;
    case '+':          k_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '_':          k_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '=':          l_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '-':          l_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case 0x1B:          exit(EXIT_SUCCESS);
    }
}
#endif


int main(int argc, char **argv)
{
    test();

#ifdef USE_GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutCreateWindow("Spirograph");
    glutInitWindowSize(400, 400);
        glutTimerFunc(animation_speed, timer_cb, 0);
    glutKeyboardFunc(keyboard_cb);
    glutDisplayFunc(test2);
    glutMainLoop();
#endif

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define MAX 20
#define INF 999

int mat[MAX][MAX];
int V;

int dist[MAX];

int q[MAX];
int qp = 0;

void enqueue(int v) { q[qp++] = v; }

int cf(void *a, void *b)
{
    int *x = (int *)a;
    int *y = (int *)b;
    return *y - *x;
}

int dequeue()
{
    qsort(q, qp, sizeof(int), cf);
    return q[--qp];
}

int queue_has_something() { return (qp > 0); }

int visited[MAX];
int vp = 0;

void dijkstra(int s)
{
    dist[s] = 0;
    int i;
    for (i = 0; i < V; ++i)
    {
        if (i != s)
        {
            dist[i] = INF;
        }
        enqueue(i);
    }
    while (queue_has_something())
    {
        int u = dequeue();
        visited[vp++] = u;
        for (i = 0; i < V; ++i)
        {
            if (mat[u][i])
            {
                if (dist[i] > dist[u] + mat[u][i])
                {
                    dist[i] = dist[u] + mat[u][i];
                }
            }
        }
    }
}

int main(int argc, char const *argv[])
{
    printf("Enter the number of vertices: ");
    scanf(" %d", &V);
    printf("Enter the adj matrix: ");
    int i, j;
    for (i = 0; i < V; ++i)
    {
        for (j = 0; j < V; ++j)
        {
            scanf(" %d", &mat[i][j]);
        }
    }

    dijkstra(0);

    printf("\nNode\tDist\n");
    for (i = 0; i < V; ++i)
    {
        printf("%d\t%d\n", i, dist[i]);
    }

    return 0;
}


long long sdbm(char s[])
{
    long long hash = 0;
    int i = 0;
    while (s[i] != '\0')
    {
        hash = s[i] + (hash << 6) + (hash << 16) - hash;
        i++;
    }
    return hash;
}

long long djb2(char s[])
{
    long long hash = 5381; 
    int i = 0;
    while (s[i] != '\0')
    {
        hash = ((hash << 5) + hash) + s[i];
        i++;
    }
    return hash;
}

char xor8(char s[])
{
    int hash = 0;
    int i = 0;
    while (s[i] != '\0')
    {
        hash = (hash + s[i]) & 0xff;
        i++;
    }
    return (((hash ^ 0xff) + 1) & 0xff);
}

int adler_32(char s[])
{
    int a = 1;
    int b = 0;
    const int MODADLER = 65521;

    int i = 0;
    while (s[i] != '\0')
    {
        a = (a + s[i]) % MODADLER;
        b = (b + a) % MODADLER;
        i++;
    }
    return (b << 16) | a;
}


#include <inttypes.h>

uint32_t crc32(char *data)
{
    int i = 0;
    uint32_t crc = 0xffffffff;
    while (data[i] != '\0')
    {
        uint8_t byte = data[i];
        crc = crc ^ byte;
        for (int j = 8; j > 0; --j)
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));

        i++;
    }
    return crc ^ 0xffffffff;
}

#include <stdio.h>
#include "hash.h"

int main(void)
{
    char s[] = "hello";

    
    printf("sdbm: %s --> %llX\n", s, sdbm(s));
    printf("djb2: %s --> %llX\n", s, djb2(s));
    printf("xor8: %s --> %X\n", s, xor8(s));         
    printf("adler_32: %s --> %X\n", s, adler_32(s)); 

    return 0;
}


#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>




#define MAX_ADALINE_ITER 500  

struct adaline
{
    double eta;      
    double *weights; 
    int num_weights; 
};


#define ADALINE_ACCURACY 1e-5


struct adaline new_adaline(const int num_features, const double eta)
{
    if (eta <= 0.f || eta >= 1.f)
    {
        fprintf(stderr, "learning rate should be > 0 and < 1\n");
        exit(EXIT_FAILURE);
    }

        int num_weights = num_features + 1;
    struct adaline ada;
    ada.eta = eta;
    ada.num_weights = num_weights;
    ada.weights = (double *)malloc(num_weights * sizeof(double));
    if (!ada.weights)
    {
        perror("Unable to allocate error for weights!");
        return ada;
    }

        for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;
    
    return ada;
}


void delete_adaline(struct adaline *ada)
{
    if (ada == NULL)
        return;

    free(ada->weights);
};


int adaline_activation(double x) { return x > 0 ? 1 : -1; }


char *adaline_get_weights_str(const struct adaline *ada)
{
    static char out[100];  
    sprintf(out, "<");
    for (int i = 0; i < ada->num_weights; i++)
    {
        sprintf(out, "%s%.4g", out, ada->weights[i]);
        if (i < ada->num_weights - 1)
            sprintf(out, "%s, ", out);
    }
    sprintf(out, "%s>", out);
    return out;
}


int adaline_predict(struct adaline *ada, const double *x, double *out)
{
    double y = ada->weights[ada->num_weights - 1];  
    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];

    if (out)          *out = y;

        return adaline_activation(y);
}


double adaline_fit_sample(struct adaline *ada, const double *x, const int y)
{
    
    int p = adaline_predict(ada, x, NULL);
    int prediction_error = y - p;      double correction_factor = ada->eta * prediction_error;

    
    for (int i = 0; i < ada->num_weights - 1; i++)
    {
        ada->weights[i] += correction_factor * x[i];
    }
    ada->weights[ada->num_weights - 1] += correction_factor;  
    return correction_factor;
}


void adaline_fit(struct adaline *ada, double **X, const int *y, const int N)
{
    double avg_pred_error = 1.f;

    int iter;
    for (iter = 0;
         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);
         iter++)
    {
        avg_pred_error = 0.f;

                for (int i = 0; i < N; i++)
        {
            double err = adaline_fit_sample(ada, X[i], y[i]);
            avg_pred_error += fabs(err);
        }
        avg_pred_error /= N;

                        printf("\tIter %3d: Training weights: %s\tAvg error: %.4f\n", iter,
               adaline_get_weights_str(ada), avg_pred_error);
    }

    if (iter < MAX_ADALINE_ITER)
        printf("Converged after %d iterations.\n", iter);
    else
        printf("Did not converged after %d iterations.\n", iter);
}




void test1(double eta)
{
    struct adaline ada = new_adaline(2, eta);  
    const int N = 10;      const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},
                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},
                                   {-9, 2}, {-10, -15}};

    double **X = (double **)malloc(N * sizeof(double *));
    const int Y[10] = {1,  -1, 1, -1, -1,
                       -1, 1,  1, 1,  -1};      for (int i = 0; i < N; i++)
    {
        X[i] = (double *)saved_X[i];
    }

    printf("------- Test 1 -------\n");
    printf("Model before fit: %s", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    double test_x[] = {5, -3};
    int pred = adaline_predict(&ada, test_x, NULL);
    printf("Predict for x=(5,-3): % d", pred);
    assert(pred == -1);
    printf(" ...passed\n");

    double test_x2[] = {5, 8};
    pred = adaline_predict(&ada, test_x2, NULL);
    printf("Predict for x=(5, 8): % d", pred);
    assert(pred == 1);
    printf(" ...passed\n");

            free(X);
    delete_adaline(&ada);
}


void test2(double eta)
{
    struct adaline ada = new_adaline(2, eta);  
    const int N = 50;  
    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));      for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));

            int range = 500;              int range2 = range >> 1;      for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;
    }

    printf("------- Test 2 -------\n");
    printf("Model before fit: %s", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[2];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;

        test_x[0] = x0;
        test_x[1] = x1;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d", x0, x1, pred);

        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}


void test3(double eta)
{
    struct adaline ada = new_adaline(6, eta);  
    const int N = 50;  
    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));      for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));

            int range = 200;              int range2 = range >> 1;      for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        X[i][2] = x2;
        X[i][3] = x0 * x0;
        X[i][4] = x1 * x1;
        X[i][5] = x2 * x2;
        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
    }

    printf("------- Test 3 -------\n");
    printf("Model before fit: %s", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[6];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        test_x[0] = x0;
        test_x[1] = x1;
        test_x[2] = x2;
        test_x[3] = x0 * x0;
        test_x[4] = x1 * x1;
        test_x[5] = x2 * x2;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d", x0, x1, pred);

        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}


int main(int argc, char **argv)
{
    srand(time(NULL));  
    double eta = 0.1;      if (argc == 2)             eta = strtof(argv[1], NULL);

    test1(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test2(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test3(eta);

    return 0;
}

#define _USE_MATH_DEFINES 
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  #include <omp.h>
#endif



#ifndef max

#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min

#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif


struct kohonen_array_3d
{
    int dim1;     
    int dim2;     
    int dim3;     
    double *data; 
};


double *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)
{
    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;
    return arr->data + offset;
}


double _random(double a, double b)
{
    return ((b - a) * (rand() % 100) / 100.f) + a;
}


int save_2d_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)      {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)      {
        for (int j = 0; j < num_features; j++)          {
            fprintf(fp, "%.4g", X[i][j]);              if (j < num_features - 1)                      fputc(',', fp);                    }
        if (i < num_points - 1)              fputc('\n', fp);         }
    fclose(fp);
    return 0;
}


int save_u_matrix(const char *fname, struct kohonen_array_3d *W)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)      {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    int R = max(W->dim1 >> 3, 2); 

    for (int i = 0; i < W->dim1; i++)      {
        for (int j = 0; j < W->dim2; j++)          {
            double distance = 0.f;
            int k;

            int from_x = max(0, i - R);
            int to_x = min(W->dim1, i + R + 1);
            int from_y = max(0, j - R);
            int to_y = min(W->dim2, j + R + 1);
            int l;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : distance)
#endif
            for (l = from_x; l < to_x; l++)              {
                for (int m = from_y; m < to_y; m++)                  {
                    double d = 0.f;
                    for (k = 0; k < W->dim3; k++)                      {
                        double *w1 = kohonen_data_3d(W, i, j, k);
                        double *w2 = kohonen_data_3d(W, l, m, k);
                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);
                                            }
                    distance += sqrt(d);
                                    }
            }

            distance /= R * R;                          fprintf(fp, "%.4g", distance);              if (j < W->dim2 - 1)                            fputc(',', fp);                     }
        if (i < W->dim1 - 1)              fputc('\n', fp);      }
    fclose(fp);
    return 0;
}


void get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)
{
    val[0] = INFINITY;  
    for (int i = 0; i < N; i++)      {
        for (int j = 0; j < N; j++)          {
            if (X[i][j] < val[0])              {                                      x_idx[0] = i;
                y_idx[0] = j;
                val[0] = X[i][j];
            }
        }
    }
}


double kohonen_update_weights(const double *X, struct kohonen_array_3d *W,
                              double **D, int num_out, int num_features,
                              double alpha, int R)
{
    int x, y, k;
    double d_min = 0.f;

#ifdef _OPENMP
#pragma omp for
#endif
        for (x = 0; x < num_out; x++)
    {
        for (y = 0; y < num_out; y++)
        {
            D[x][y] = 0.f;
                                    for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);
            }
            D[x][y] = sqrt(D[x][y]);
        }
    }

            int d_min_x, d_min_y;
    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);

        int from_x = max(0, d_min_x - R);
    int to_x = min(num_out, d_min_x + R + 1);
    int from_y = max(0, d_min_y - R);
    int to_y = min(num_out, d_min_y + R + 1);

        #ifdef _OPENMP
#pragma omp for
#endif
    for (x = from_x; x < to_x; x++)
    {
        for (y = from_y; y < to_y; y++)
        {
            
                        
            
            double d2 =
                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);
            double scale_factor = exp(-d2 / (2.f * alpha * alpha));

            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                                w[0] += alpha * scale_factor * (X[k] - w[0]);
            }
        }
    }
    return d_min;
}


void kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,
                 int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double **D = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < num_out; i++)
        D[i] = (double *)malloc(num_out * sizeof(double));

    double dmin = 1.f;  
        for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;
         alpha -= 0.001, iter++)
    {
        dmin = 0.f;
                for (int sample = 0; sample < num_samples; sample++)
        {
                        dmin += kohonen_update_weights(X[sample], W, D, num_out,
                                           num_features, alpha, R);
        }

                if (iter % 100 == 0 && R > 1)
            R--;

        dmin /= num_samples;
        printf("iter: %5d\t alpha: %.4g\t R: %d\td_min: %.4g\r", iter, alpha, R,
               dmin);
    }
    putchar('\n');

    for (int i = 0; i < num_out; i++) free(D[i]);
    free(D);
}




void test_2d_classes(double *const *data, int N)
{
    const double R = 0.3;      int i;
    const int num_classes = 4;
    const double centres[][2] = {
                {.5, .5},           {.5, -.5},          {-.5, .5},          {-.5, -.5}      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  
                data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);

        
    }
}


void test1()
{
    int j, N = 300;
    int features = 2;
    int num_out = 30;  
        double **X = (double **)malloc(N * sizeof(double *));

        struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  
    for (int i = 0; i < max(num_out, N); i++)      {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_2d_classes(X, N);      save_2d_data("test1.csv", X, N, features);      save_u_matrix("w11.csv", &W);                   kohonen_som(X, &W, N, features, num_out, 1e-4);      save_u_matrix("w12.csv", &W);  
    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}


void test_3d_classes1(double *const *data, int N)
{
    const double R = 0.2;      int i;
    const int num_classes = 4;
    const double centres[][3] = {
                {.5, .5, .5},            {.5, -.5, -.5},          {-.5, .5, .5},           {-.5, -.5 - .5}      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  
                data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        
    }
}


void test2()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;  
        double **X = (double **)malloc(N * sizeof(double *));

        struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  
    for (int i = 0; i < max(num_out, N); i++)      {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++)
                {                      double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes1(X, N);                         save_2d_data("test2.csv", X, N, features);      save_u_matrix("w21.csv", &W);                   kohonen_som(X, &W, N, features, num_out, 1e-4);      save_u_matrix("w22.csv", &W);  
    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}


void test_3d_classes2(double *const *data, int N)
{
    const double R = 0.2;      int i;
    const int num_classes = 8;
    const double centres[][3] = {
                {.5, .5, .5},            {.5, .5, -.5},           {.5, -.5, .5},           {.5, -.5, -.5},          {-.5, .5, .5},           {-.5, .5, -.5},          {-.5, -.5, .5},          {-.5, -.5, -.5}      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  
                data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        
    }
}


void test3()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;
    double **X = (double **)malloc(N * sizeof(double *));

        struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  
    for (int i = 0; i < max(num_out, N); i++)      {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes2(X, N);      save_2d_data("test3.csv", X, N, features);      save_u_matrix("w31.csv", &W);                   kohonen_som(X, &W, N, features, num_out, 0.01);      save_u_matrix("w32.csv", &W);  
    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}


double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}


int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk, end_clk;

    start_clk = clock();
    test1();
    end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    printf("(Note: Calculated times include: writing files to disk.)\n\n");
    return 0;
}

#define _USE_MATH_DEFINES 
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  #include <omp.h>
#endif



#ifndef max

#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min

#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif


double _random(double a, double b)
{
    int r = rand() % 100;
    return ((b - a) * r / 100.f) + a;
}


int save_nd_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)      {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)      {
        for (int j = 0; j < num_features; j++)          {
            fprintf(fp, "%.4g", X[i][j]);              if (j < num_features - 1)                      fprintf(fp, ",");                  }
        if (i < num_points - 1)              fprintf(fp, "\n");       }
    fclose(fp);
    return 0;
}


void kohonen_get_min_1d(double const *X, int N, double *val, int *idx)
{
    val[0] = INFINITY;  
    for (int i = 0; i < N; i++)      {
        if (X[i] < val[0])          {                               idx[0] = i;
            val[0] = X[i];
        }
    }
}


void kohonen_update_weights(double const *x, double *const *W, double *D,
                            int num_out, int num_features, double alpha, int R)
{
    int j, k;

#ifdef _OPENMP
#pragma omp for
#endif
        for (j = 0; j < num_out; j++)
    {
        D[j] = 0.f;
                        for (k = 0; k < num_features; k++)
            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);
    }

            int d_min_idx;
    double d_min;
    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);

        int from_node = max(0, d_min_idx - R);
    int to_node = min(num_out, d_min_idx + R + 1);

        #ifdef _OPENMP
#pragma omp for
#endif
    for (j = from_node; j < to_node; j++)
        for (k = 0; k < num_features; k++)
                        W[j][k] += alpha * (x[k] - W[j][k]);
}


void kohonen_som_tracer(double **X, double *const *W, int num_samples,
                        int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double alpha = 1.f;
    double *D = (double *)malloc(num_out * sizeof(double));

        for (; alpha > alpha_min; alpha -= 0.01, iter++)
    {
                for (int sample = 0; sample < num_samples; sample++)
        {
            const double *x = X[sample];
                        kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);
        }

                if (iter % 10 == 0 && R > 1)
            R--;
    }

    free(D);
}




void test_circle(double *const *data, int N)
{
    const double R = 0.75, dr = 0.3;
    double a_t = 0., b_t = 2.f * M_PI;      double a_r = R - dr, b_r = R + dr;      int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double r = _random(a_r, b_r);              double theta = _random(a_t, b_t);          data[i][0] = r * cos(theta);               data[i][1] = r * sin(theta);
    }
}


void test1()
{
    int j, N = 500;
    int features = 2;
    int num_out = 50;

        double **X = (double **)malloc(N * sizeof(double *));

        double **W = (double **)malloc(num_out * sizeof(double *));

    for (int i = 0; i < max(num_out, N); i++)      {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            W[i] = (double *)malloc(features * sizeof(double));
#ifdef _OPENMP
#pragma omp for
#endif
                        for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_circle(X, N);      save_nd_data("test1.csv", X, N, features);      save_nd_data("w11.csv", W, num_out,
                 features);      kohonen_som_tracer(X, W, N, features, num_out, 0.1);      save_nd_data("w12.csv", W, num_out,
                 features);  
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
}


void test_lamniscate(double *const *data, int N)
{
    const double dr = 0.2;
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double dx = _random(-dr, dr);             double dy = _random(-dr, dr);             double theta = _random(0, M_PI);          data[i][0] = dx + cos(theta);             data[i][1] = dy + sin(2. * theta) / 2.f;
    }
}


void test2()
{
    int j, N = 500;
    int features = 2;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
                        for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_lamniscate(X, N);      save_nd_data("test2.csv", X, N, features);      save_nd_data("w21.csv", W, num_out,
                 features);      kohonen_som_tracer(X, W, N, features, num_out, 0.01);      save_nd_data("w22.csv", W, num_out,
                 features);  
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}


void test_3d_classes(double *const *data, int N)
{
    const double R = 0.1;      int i;
    const int num_classes = 4;
    const double centres[][3] = {
                {.5, .5, .5},            {.5, -.5, -.5},          {-.5, .5, .5},           {-.5, -.5 - .5}      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  
                data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        
    }
}


void test3()
{
    int j, N = 200;
    int features = 3;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)              X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)          {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
                        for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_3d_classes(X, N);      save_nd_data("test3.csv", X, N, features);      save_nd_data("w31.csv", W, num_out,
                 features);      kohonen_som_tracer(X, W, N, features, num_out, 0.01);      save_nd_data("w32.csv", W, num_out,
                 features);  
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}


double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}


int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk = clock();
    test1();
    clock_t end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    printf(
        "(Note: Calculated times include: creating test sets, training "
        "model and writing files to disk.)\n\n");
    return 0;
}
#include <stdio.h>

int power(int x, unsigned int y)
{
    if (y == 0)
        return 1;
    if (y % 2 == 0)
        return power(x, y / 2) * power(x, y / 2);
    return x * power(x, y / 2) * power(x, y / 2);
}

int order(int x)
{
    int n = 0;
    while (x)
    {
        n++;
        x = x / 10;
    }
    return n;
}

int isArmstrong(int x)
{
        int n = order(x);
    int temp = x, sum = 0;
    while (temp)
    {
        int r = temp % 10;
        sum += power(r, n);
        temp = temp / 10;
    }

        if (sum == x)
        return 1;
    else
        return 0;
}

int main()
{
    int x = 153;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    x = 1253;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct _cantor_set
{
    double start;             
    double end;               
    struct _cantor_set *next; 
} CantorSet;


void propagate(CantorSet *head)
{
        if (head == NULL)
        return;

    CantorSet *temp = head;  
        CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));

        double diff = (((temp->end) - (temp->start)) / 3);

        newNode->end = temp->end;
    temp->end = ((temp->start) + diff);
    newNode->start = (newNode->end) - diff;

        newNode->next = temp->next;

        temp->next = newNode;

        propagate(temp->next->next);
}


void print(CantorSet *head)
{
    CantorSet *temp = head;
    while (temp != NULL)      {
        printf("\t");
        printf("[%lf] -- ", temp->start);
        printf("[%lf]", temp->end);
        temp = temp->next;
    }

    printf("\n");
}


void free_memory(CantorSet *head)
{
    if (!head)
        return;

    if (head->next)
        free_memory(head->next);

    free(head);
}


int main(int argc, char const *argv[])
{
    int start_num, end_num, levels;

    if (argc < 2)
    {
        printf("Enter 3 arguments: start_num \t end_num \t levels\n");
        scanf("%d %d %d", &start_num, &end_num, &levels);
    }
    else
    {
        start_num = atoi(argv[1]);
        end_num = atoi(argv[2]);
        levels = atoi(argv[3]);
    }

    if (start_num < 0 || end_num < 0 || levels < 0)
    {
        fprintf(stderr, "All numbers must be positive\n");
        return -1;
    }

    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};

        for (int i = 0; i < levels; i++)
    {
        printf("Level %d\t", i);
        print(&head);
        propagate(&head);
        printf("\n");
    }
    printf("Level %d\t", levels);
    print(&head);

        free_memory(head.next);

    return 0;
}

#define _USE_MATH_DEFINES 
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>


void to_polar(double x, double y, double *r, double *theta)
{
    double thetaFinal = 0.f;

    *r = sqrt(x * x + y * y);

    if (x != 0)
    {
        if (y != 0)
        {
            *theta = atan(y / x);
            if ((x > 0 && y > 0) || (x == -y))
            {                  thetaFinal = *theta;
            }
            else if (x < 0 && y > 0)
            {                  thetaFinal = *theta + M_PI;
            }
            else if (x < 0 && y < 0)
            {                  thetaFinal = *theta - M_PI;
            }
            else if (x > 0 && y < 0)
            {                  thetaFinal = 2 * M_PI - *theta;
            }
            else
            {
                fprintf(stderr, "Should not reach here!\n");
            }
        }
    }
    else
    {          if (y > 0)
        {
            thetaFinal = M_PI / 2;
        }
        else
        {
            thetaFinal = -(M_PI / 2);
        }
    }
    if (y == 0)
    {
        if (x > 0)
        {
            thetaFinal = 0;
        }
        else
        {
            thetaFinal = -M_PI;
        }
    }

    *theta = thetaFinal;
}


double get_rand(double lim1, double lim2)
{
    double r = (double)rand() / RAND_MAX;      return (lim2 - lim1) * r + lim1;       }


void test()
{
    srand(10);
    int NUM_TESTS = 5;

    for (int i = 0; i < NUM_TESTS; i++)
    {
        double r, theta;
        printf("Test %d.... ", i);
        double x = get_rand(-5, 5);
        double y = get_rand(-5, 5);
        printf("(%.2g, %.2g).... ", x, y);
        to_polar(x, y, &r, &theta);
        assert(fabs(r - hypot(x, y)) < 0.01);
        assert(fabs(theta - atan2(y, x)) < 0.01);
        printf("passed\n");
    }
}


int main()
{
    test();

    return 0;
}

#include <stdio.h>
long int factorial(int x)  {
    int i;
    long int fac;      fac = x;
    for (i = 1; i < x; i++)      {
        fac = fac * (x - i);
    }
    return fac;  }
int main()
{
    long int f1, f2, f3;      int n;
    float C;      scanf("%d", &n);
    f1 = factorial(2 * n);
    f2 = factorial(n + 1);
    f3 = factorial(n);
    C = f1 / (f2 * f3);      printf("%0.2f", C);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>


int main(int argc, char *argv[])
{
    unsigned long long n, curr_no, num_steps = 0;
    if (argc == 2)
        n = strtoull(argv[1], NULL, 10);
    else
    {
        printf("Enter starting number: ");
        scanf("%lu", &n);      }

    curr_no = n;              while (curr_no != 1)      {
        num_steps++;
        printf("%llu->", curr_no);
        if (curr_no % 2 == 0)              curr_no = curr_no / 2;
        else
            curr_no = (curr_no * 3) + 1;      }
    printf("1\nNumber of steps: %llu\n", num_steps);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>

int ways(int n, int *a, int k)
{
    if (n < 0 || k < 0)
        return 0;
    if (n == 0)
        return 1;
    if (k == 0)
        return 0;
    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);
}

int main()
{
    int m;
    int t;
    int n;

    printf("Number of coins? ");
    scanf("%d", &m);
    int *coin = (int *)malloc(m * sizeof(int)), i;
    for (i = 0; i < m; i++)
    {
        printf("coin? ");
        scanf("%d", &coin[i]);
    }

    printf("---- your requests --- \n");
    while (1)
    {
        printf("amount? exit(0) ");
        scanf("%d", &n);
        if (!n)
        {
            break;
        }
        printf("%d\n", ways(n, coin, m));
    }

    free(coin);
    return 0;
}
#include <stdio.h>
int main()
{
    int a[200], n, counter, temp, i;
    a[0] = 1;
    counter = 0;
    printf("Enter a whole number to Find its Factorial: ");
    scanf("%d", &n);
    if (n < 0)
        printf("Cannot Calculate factorials for negative numbers.");
    else
    {
        for (; n >= 2; n--)
        {
            temp = 0;
            for (i = 0; i <= counter; i++)
            {
                temp = (a[i] * n) + temp;
                a[i] = temp % 10;
                temp = temp / 10;
            }
            while (temp > 0)
            {
                a[++counter] = temp % 10;
                temp = temp / 10;
            }
        }
        for (i = counter; i >= 0; i--) printf("%d", a[i]);
    }
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


typedef struct _large_num
{
    char *digits;            
    unsigned int num_digits; 
} large_num;


large_num *new_number(void)
{
    large_num *new_num = (large_num *)malloc(sizeof(large_num));
    new_num->num_digits = 1;
    new_num->digits = (char *)malloc(1 * sizeof(char));
    new_num->digits[0] = 1;
    return new_num;
}


void delete_number(large_num *num)
{
    free(num->digits);
    free(num);
}


void add_digit(large_num *num, unsigned int value)
{
    if (value > 9)
    {
        fprintf(stderr, "digit > 9!!\n");
        delete_number(num);
        exit(EXIT_FAILURE);
    }

    num->num_digits++;
    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));
    num->digits[num->num_digits - 1] = value;
}


void multiply(large_num *num, unsigned long n)
{
    int i;
    unsigned long carry = 0, temp;
    for (i = 0; i < num->num_digits; i++)
    {
        temp = num->digits[i] * n;
        temp += carry;
        if (temp < 10)
            carry = 0;
        else
        {
            carry = temp / 10;
            temp = temp % 10;
        }
        num->digits[i] = temp;
    }

    while (carry != 0)
    {
        add_digit(num, carry % 10);
        carry /= 10;
    }
}


int main(int argc, char *argv[])
{
    int number, i;

        if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    large_num *result = new_number();

    clock_t start_time = clock();
    for (i = 2; i <= number; i++) 
        multiply(result, i);
    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;
    
    printf("%d! = ", number);
    for (i = result->num_digits; i > 0; i--)
        putchar(result->digits[i - 1] + '0');
    printf("\nTime taken: %.4g ms\n", time_taken);

    delete_number(result);
    return 0;
}

#include <math.h>  #include <stdio.h>
int main()
{
    int i, n, test = 0, count = 0;
        scanf("%d", &n);

        for (i = 1;; i++)
    {
        test =
            n /
            pow(5,
                i);          if (test !=
            0)          {
            count = count + test;
        }
        else
            break;      }
    printf("%d\n", count);
    return 0;
}
#include <stdio.h>

int fib(int number)
{
    if (number == 1 || number == 2)
        return 1;
    else
        return fib(number - 1) + fib(number - 2);
}

int main()
{
    int number;

        printf("Number: ");
    scanf("%d", &number);

    printf("%d \n", fib(number));

    return 0;
}


#include <stdio.h>
#include <stdlib.h>

int fib(int n)
{
        if (n < 0)
    {
        printf("\nNo Such term !\n");
        exit(0);
    }
        int *f = (int *)malloc(
        (n + 2) * sizeof(int));      int i;

    
    f[0] = 0;
    f[1] = 1;

    for (i = 2; i <= n; i++)
    {
                f[i] = f[i - 1] + f[i - 2];
    }

    int out = f[n];
    free(f);
    return out;
}

int main(int argc, char *argv[])
{
    int number;

        if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    printf("The nth term is : %d \n", fib(number));

    return 0;
}

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>


void fib(unsigned long n, unsigned long *C, unsigned long *D)
{
                            
    unsigned long a, b, c, d;

    if (n == 0)
    {
        C[0] = 0;
        if (D) 
            D[0] = 1;
        return;
    }

    fib(n >> 1, &c, &d); 

    a = c * ((d << 1) - c);
    b = c * c + d * d;
    if (n % 2 == 0) 
    {
        C[0] = a;
        if (D)
            D[0] = b;
        return;
    }

    
    C[0] = b;
    if (D) 
        D[0] = a + b;
    return;
}


int main(int argc, char *argv[])
{
    unsigned long number, result;

    setlocale(LC_NUMERIC, "");  
        if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%lu", &number);
    }

    fib(number, &result, NULL);

    printf("The nth term is : %'lu \n", result);

    return 0;
}
#include <stdio.h>

int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}

int main()
{
    int a, b;
    printf("Input two numbers:\n");
    scanf("%d %d", &a, &b);
    printf("Greatest common divisor: %d\n", GCD(a, b));
}
#include <stdio.h>

int main()
{
    int n, sum = 0, i, num;
    printf("Enter number: ");
    scanf("%d", &n);
    num = n;
    while (n != 0)
    {
        i = n % 10;
        sum = sum + (i * i * i);
        n = n / 10;
    }
    if (sum == num)
    {
        printf("%d is an armstrong number!\n", num);
    }
    else
    {
        printf("%d is not an armstrong number!\n", num);
    }
    return 0;
}
#include <stdio.h>

int main()
{
    int a[16500], T;
    long long int i, j;

    printf("Enter number of test cases : ");
    scanf("%d", &T);

    while (T--)
    {
        for (i = 0; i < 16500; i++)
        {
            a[i] = 0;
        }

        a[1] = 1;
        int N, carry = 0, count = 0;
        printf("Enter a number : ");
        scanf("%d", &N);

        for (i = 1; i <= N; i++)
        {
            carry = 0;
            for (j = 0; j < 16500; j++)
            {
                a[j] = a[j] * i + carry;
                carry = a[j] / 10;
                a[j] = a[j] % 10;
            }
        }

        for (i = 0; i < 16500; i++)
        {
            if (a[i] != 0)
            {
                count = i;
            }
        }

        for (i = count; i > 0; i--)
        {
            printf("%d", a[i]);
        }
        printf("\n");
    }

    return 0;
}

#include <stdio.h>

int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

int lcm(int a, int b) { return (a * b) / gcd(a, b); }

int main()
{
    int a, b;
    printf("Enter two numbers to find their LCM \n");
    scanf("%d%d", &a, &b);
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}

#include <math.h>
#include <stdio.h>

float lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }

float lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }

int main()
{
    float start = 0;
    float finish = 5;
    float steps = 0;

    printf("Input a number, this is the bigger bound of the lerp:\n");
    scanf("%f", &finish);

    printf(
        "Input a number, this is in how many steps you want to divide the "
        "lerp:\n");
    scanf("%f", &steps);

    for (int i = 0; i < steps + 1; i++)
    {
        printf("%f\n", lerp(start, finish, i / steps));
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void swap(char *left, char *right)
{
    char temp = *left;
    *left = *right;
    *right = temp;
}

int compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }

void PrintSortedPermutations(char *str)
{
    int strSize = strlen(str);
    qsort(str, strSize, sizeof(char), compare);

    int largerPermFound = 1;
    do
    {
                printf("%s\n", str);
                int i;
        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)
        {
        }

                if (i >= 0)
        {
                                    int j = i + 1, k;
            for (k = j; k < strSize && str[k]; k++)
            {
                if (str[k] > str[i] && str[k] < str[j])
                    j = k;
            }
                        swap(&str[i], &str[j]);
                        qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);
        }
        else
            largerPermFound = 0;
    } while (largerPermFound);
}

int main()
{
    int n;      scanf("%d\n", &n);
    if (n <= 0 || n >= 1000)
    {
        perror("Input number out of range: >0 and <1000\n");
        return -1;
    }
    char *str = (char *)malloc(n * sizeof(char));
    scanf("%s", str);
    PrintSortedPermutations(str);
    free(str);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)
{  
    if (ARRAY_LENGTH <= 1)
    {
        *RESULT = ARRAY;
        *RESULT_LENGTH = ARRAY_LENGTH;
    }
    else
    {
        int PIVOT = ARRAY[0];
        int *LONGEST_SUB = NULL;
        int i, j, LONGEST_SUB_LENGTH = 0;
        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;

        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] < PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH = 0;
                TEMPORARY_ARRAY = NULL;

                for (j = i + 1; j < ARRAY_LENGTH; j++)
                {
                    if (ARRAY[j] >= ARRAY[i])
                    {
                        TEMPORARY_ARRAY_LENGTH++;
                        TEMPORARY_ARRAY = (int *)realloc(
                            TEMPORARY_ARRAY,
                            TEMPORARY_ARRAY_LENGTH * sizeof(int));
                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];
                    }
                }

                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,
                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);
                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)
                {
                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
                    LONGEST_SUB = (int *)realloc(
                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
                    LONGEST_SUB[0] = ARRAY[i];

                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
                }
            }
        }

        TEMPORARY_ARRAY = NULL;
        TEMPORARY_ARRAY_LENGTH = 0;
        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] >= PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH++;
                TEMPORARY_ARRAY = (int *)realloc(
                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));
                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];
            }
        }

        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,
                   &TEMPORARY_ARRAY_LENGTH);
        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)
        {
            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
            LONGEST_SUB =
                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
            LONGEST_SUB[0] = PIVOT;
            for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
        }
        *RESULT = LONGEST_SUB;
        *RESULT_LENGTH = LONGEST_SUB_LENGTH;
    }
}

int main()
{
    int EXAMPLE_LENGTH = 8;
    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};

    int *RESULT = NULL;
    int RESULT_LENGTH, i;

    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);

    printf("Longest Sub Sequence length: %d and it's:\n", RESULT_LENGTH);
    for (i = 0; i < RESULT_LENGTH; i++) printf("%d ", RESULT[i]);
    printf("\n");

    return 0;
}#include <stdio.h>
#include <string.h>  
void saisie(
    char *cpointeur);  int compte(char *s);
char *miroir(char *s);

int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf("miroir est %s", miroir(chaine));
}
void saisie(char *cpointeur)
{
    printf("saisir une chaine\n");
    scanf("%s", cpointeur);
}

char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}

int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

bool isPalindrome(int number);


int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}


bool isPalindrome(int number)
{
    int reversedNumber = 0;
    int originalNumber = number;
    while (number != 0)
    {
        int remainder = number % 10;
        reversedNumber = reversedNumber * 10 + remainder;
        number /= 10;
    }
    return originalNumber == reversedNumber;
}

#include <stdio.h>

struct pid
{
        float kP;
    float kI;
    float kD;

        float lastError;
    float integral;
};

float pid_step(struct pid *controller, float dt, float error)
{
        float p = error * controller->kP;

        controller->integral += error * dt * controller->kI;

        float d =
        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;
    controller->lastError = error;

    return p + controller->integral + d;
}

int main()
{
    printf("PID Controller Example\n");

    struct pid controller = {.lastError = 0, .integral = 0};

        printf(
        "Please enter controller gains in format kP, kI, KD. For example, "
        "\"1.2 2.1 3.2\"\n> ");
    scanf("%f %f %f", &controller.kP, &controller.kI, &controller.kD);
    printf("Using kP: %f, kI: %f, kD: %f\n", controller.kP, controller.kI,
           controller.kD);

                        float time_step = 1;

    float error_value;
    while (1)
    {
        printf("Enter error value\n>");
        scanf("%f", &error_value);

        float output = pid_step(&controller, time_step, error_value);
        printf("Output: %f\n", output);
    }
}
#include <math.h>
#include <stdio.h>

int isPrime(int x)
{
    if (x == 2)
    {
        return 1;
    }
    if (x < 2 || x % 2 == 0)
    {
        return 0;
    }

    double squareRoot = sqrt(x);

    for (int i = 3; i <= squareRoot; i += 2)
    {
        if (x % i == 0)
            return 0;
    }
    return 1;
}

int main()
{
    int a;
    printf("Input a number to see if it is a prime number:\n");
    scanf("%d", &a);
    if (isPrime(a))
        printf("%d is a prime number.\n", a);
    else
        printf("%d is not a prime number.\n", a);
    return 0;
}


#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define LEN 10


#define STEP 5


typedef struct data
{
    int *range;
    int length;
} range;
typedef range *Range;


Range int_fact(int);


void print_arr(Range);


int *increase(int *, int);


void destroy(Range);


int main()
{
    int n = 0; 

    printf("\t\tPrim factoriziation\n\n");
    printf("positive integer (> 1) ? ");
    scanf("%d", &n);
    Range r = int_fact(n);
    printf("\nThe factoriziation are: ");
    print_arr(r);
    destroy(r);
    return 0;
}

Range int_fact(int n)
{
    assert(n > 1); 

    int len = LEN;
    int count = 0;
    int i = 0;
    int *range = (int *)malloc(sizeof(int) * len);
    assert(range);
    Range pstr = (Range)malloc(sizeof(range));
    assert(pstr);

    while (n % 2 == 0)
    {
        n /= 2;
        if (i < len)
        {
            range[i] = 2;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = 2;
            i++;
        }
        count++;
    }

    int j = 3;
    while (j * j <= n)
    {
        while (n % j == 0)
        {
            n /= j;
            if (i < len)
            {
                range[i] = j;
                i++;
            }
            else
            {
                range = increase(range, len);
                len += STEP;
                range[i] = j;
                i++;
            }
            count++;
        }

        j += 2;
    }

    if (n > 1)
    {
        if (i < len)
        {
            range[i] = n;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = n;
            i++;
        }
        count++;
    }

    pstr->range = range;
    pstr->length = count;
    return pstr;
}

void print_arr(Range pStr)
{
    assert(pStr); 
    int i = 0;
    printf("\n");
    for (i; i < pStr->length; i++)
    {
        if (i == 0)
            printf("%d", pStr->range[0]);
        else
            printf("-%d", pStr->range[i]);
    }
    printf("\n");
}

int *increase(int *arr, int len)
{
    assert(arr); 
    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));
    assert(tmp);
    return tmp;
    }

void destroy(Range r)
{
    free(r->range);
    free(r);
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float q1, q3, iqr;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    q1 = a[n / 4];
    printf("\nFirst Quartile : %f", q1);
    q3 = a[(3 * n) / 4];
    printf("\nThird Quartile : %f", q3);
    iqr = q3 - q1;
    printf("\nInterQuartile Range is : %f", iqr);

    return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <time.h>
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
int part(int a[], int l, int r, int n, int pivot, int pindex)
{
    int p1 = l, p2 = r;
    while (p2 > p1)
    {
        if (a[p1] > pivot && a[p2] < pivot)
        {
            swap(&a[p1], &a[p2]);
        }
        else
        {
            if (a[p1] <= pivot)
            {
                p1++;
            }
            if (a[p2] >= pivot)
            {
                p2--;
            }
        }
    }
    swap(&a[pindex], &a[p2]);
    return p2;
}
int rselect(int a[], int l, int r, int n, int o)
{
    int pivot, pindex, pactual;
    if (r > l)
    {
        pindex = rand() % (r - l + 1);
        pivot = a[pindex];
        pactual = part(a, l, r, n, pivot, pindex);

        if (pactual == o)
        {
            return a[pactual];
        }

        if (o < pactual)
        {
            rselect(a, l, pactual - 1, n, o);
        }

        if (o > pactual)
        {
            rselect(a, pactual + 1, r, n, o - pactual);
        }
    }
    if (r == l)
    {
        return a[l];
    }
    return -1;
}
int main()
{
    srand(time(NULL));
    int n, o, i, *a;
    scanf("%d %d", &n, &o);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", a + i);
    }
    printf("\n\n%d", rselect(a, 0, n - 1, n, o));
    return 0;
}


#include <stdio.h>

void strng(int a)
{
    int j = a;
    int sum = 0;
    int b, i, fact = 1;
    while (a > 0)
    {
        fact = 1;
        b = a % 10;
        for (i = 1; i <= b; i++)
        {
            fact = fact * i;
        }
        a = a / 10;
        sum = sum + fact;
    }
    if (sum == j)
        printf("%d is a strong number", j);
    else
        printf("%d is not a strong number", j);
}
int main()
{
    int a;
    printf("Enter the number to check");
    scanf("%d", &a);
    strng(a);
    return 0;
}

#include <assert.h>
#include <inttypes.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>



struct sudoku
{
    uint8_t *a; 
    uint8_t N;  
    uint8_t N2; 
};


bool OKrow(const struct sudoku *a, int x, int y, int v)
{
    int offset = x * a->N;
    for (int j = 0; j < a->N; j++)
        if (a->a[offset + j] == v)
                        return false;
    return true;
}


bool OKcol(const struct sudoku *a, int x, int y, int v)
{
    for (int i = 0; i < a->N; i++)
        if (a->a[i * a->N + y] == v)
                        return false;
    return true;
}


bool OKbox(const struct sudoku *a, int x, int y, int v)
{
    
    int bi = x - x % a->N2, bj = y - y % a->N2;
    
    for (int i = bi; i < (bi + a->N2); i++)
        for (int j = bj; j < (bj + a->N2); j++)
            if (a->a[i * a->N + j] == v)
                                return false;
    return true;
}


bool OK(const struct sudoku *a, int x, int y, int v)
{
    bool result = OKrow(a, x, y, v);
    if (result)
        result = OKcol(a, x, y, v);
    if (result)
        result = OKbox(a, x, y, v);

    return result;
}


void print(const struct sudoku *a)
{
    int i, j;
    for (i = 0; i < a->N; i++)
        for (j = 0; j < a->N; j++)
            printf("%" SCNu8 "%c", a->a[i * a->N + j],
                   (j == a->N - 1 ? '\n' : ' '));
}


bool get_next_unknown(const struct sudoku *a, int *x, int *y)
{
    for (int i = 0; i < a->N; i++)
    {
        for (int j = 0; j < a->N; j++)
        {
            if (a->a[i * a->N + j] == 0)
            {
                *x = i;
                *y = j;
                return true;
            }
        }
    }

    
    return false;
}


bool solve(struct sudoku *a)
{
    static uint32_t counter = 0;
    int i, j;
    static char prefix[100] = "";  
    if (!get_next_unknown(a, &i, &j))
    {
        
        return true;
    }

    
    for (uint8_t v = 1; v <= a->N; v++)
    { 
        printf("%sTry (%d,%d) = %" SCNu8 "... ", prefix, i, j, v);
        counter++;
        if (OK(a, i, j, v))
        {
            
            printf("passed (counter=%" SCNu32 ")\n", counter);
            a->a[i * a->N + j] = v;
            strcat(prefix, "  ");
            if (solve(a))
            {
                
                return true;
            }

            printf("%sBacktrack (%d,%d) <- %" SCNu8 " (counter=%" SCNu32 ")\n",
                   prefix, i, j, a->a[i * a->N + j], counter);

            prefix[strlen(prefix) - 2] = '\0';              a->a[i * a->N + j] = 0;
        }
        else
        {
            printf("\r");
        }
    }

    return false;
}



void test()
{
    printf("Test begin...\n");

    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,
                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,
                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,
                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,
                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};
    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};
    assert(solve(&a));  
    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,
                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,
                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,
                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,
                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};
    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++)
            assert(a.a[i * a.N + j] == expected[i * a.N + j]);

    printf("Test passed\n");
}


int main()
{
    test();

    struct sudoku a;      scanf("%" SCNu8, &(a.N));
    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));
    a.N2 = (uint8_t)sqrt(a.N);

    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++) scanf("%" SCNu8, &(a.a[i * a.N + j]));

    printf("Entered a %udx%ud matrix with block size: %" SCNu8 "\n", a.N, a.N,
           a.N2);
        printf("\n\n");
    if (solve(&a))
        printf("Valid solution found!\n");
    else
        printf("Invalid\n");
    print(&a);

    free(a.a);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>

void hanoi(int noOfDisks, char where, char to, char extra)
{
    if (noOfDisks != 0)
    {
        hanoi(noOfDisks - 1, where, extra, to);
        printf("Move disk : %d from %c to %c\n", noOfDisks, where, to);
        hanoi(noOfDisks - 1, extra, to, where);
    }
}
int main(void)
{
    int noOfDisks;

        printf("Number of disks: \n");
    scanf("%d", &noOfDisks);

    hanoi(noOfDisks, 'A', 'B', 'C');

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 1000 


int find(int *p, int x)
{
    if (x >= MAX_SIZE)
    {
        fprintf(stderr, "Out-of bounds value\n");
        exit(EXIT_FAILURE);
    }

    if (p[x] == x)
    {
        return x;
    }
    else
    {
        p[x] = find(p, p[x]);
        return p[x];
    }
}


void join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }


int main()
{
    int union_set[MAX_SIZE];

        for (int i = 0; i < 10; i++)
    {
        union_set[i] = i;
    }
    
    join(union_set, 3, 5);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");
        
    join(union_set, 3, 8);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

            join(union_set, 0, 5);
    if (find(union_set, 0) == find(union_set, 3))
    {
        printf("0 and 3 are groupped together\n");
    }
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

    return 0;
}


#include <complex.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define ACCURACY 1e-10 


long double complex poly_function(long double *coeffs, unsigned int degree,
                                  long double complex x)
{
    long double complex out = 0.;
    unsigned int n;

    for (n = 0; n < degree; n++) out += coeffs[n] * cpow(x, degree - n - 1);

    return out;
}


const char *complex_str(long double complex x)
{
    static char msg[50];
    double r = creal(x);
    double c = cimag(x);

    sprintf(msg, "% 7.04g%+7.04gj", r, c);

    return msg;
}


char check_termination(long double delta)
{
    static long double past_delta = INFINITY;
    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)
        return 1;
    past_delta = delta;
    return 0;
}


int main(int argc, char **argv)
{
    long double *coeffs = NULL;
    long double complex *s0 = NULL;
    unsigned int degree = 0;
    unsigned int n, i;

    if (argc < 2)
    {
        printf(
            "Please pass the coefficients of the polynomial as commandline "
            "arguments.\n");
        return 0;
    }

    degree = argc - 1; 
    coeffs = (long double *)malloc(
        degree * sizeof(long double)); 
    s0 = (long double complex *)malloc(
        (degree - 1) *
        sizeof(long double complex)); 

    
    srand(time(NULL));

    if (!coeffs || !s0)
    {
        perror("Unable to allocate memory!");
        if (coeffs)
            free(coeffs);
        if (s0)
            free(s0);
        return EXIT_FAILURE;
    }

#if defined(DEBUG) || !defined(NDEBUG)
    
    FILE *log_file = fopen("durand_kerner.log.csv", "wt");
    if (!log_file)
    {
        perror("Unable to create a storage log file!");
        free(coeffs);
        free(s0);
        return EXIT_FAILURE;
    }
    fprintf(log_file, "iter#,");
#endif

    printf("Computing the roots for:\n\t");
    for (n = 0; n < degree; n++)
    {
        coeffs[n] = strtod(argv[n + 1], NULL);
        if (n < degree - 1 && coeffs[n] != 0)
            printf("(%Lg) x^%d + ", coeffs[n], degree - n - 1);
        else if (coeffs[n] != 0)
            printf("(%Lg) x^%d = 0\n", coeffs[n], degree - n - 1);

        double tmp;
        if (n > 0)
            coeffs[n] /= tmp; 
        else
        {
            tmp = coeffs[0];
            coeffs[0] = 1;
        }

        
        if (n < degree - 1)
        {
            s0[n] = (long double)rand() + (long double)rand() * I;
#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "root_%d,", n);
#endif
        }
    }

#if defined(DEBUG) || !defined(NDEBUG)
    fprintf(log_file, "avg. correction");
    fprintf(log_file, "\n0,");
    for (n = 0; n < degree - 1; n++)
        fprintf(log_file, "%s,", complex_str(s0[n]));
#endif

    double tol_condition = 1;
    unsigned long iter = 0;

    clock_t end_time, start_time = clock();
    while (!check_termination(tol_condition) && iter < INT_MAX)
    {
        long double complex delta = 0;
        tol_condition = 0;
        iter++;

#if defined(DEBUG) || !defined(NDEBUG)
        fprintf(log_file, "\n%ld,", iter);
#endif

        for (n = 0; n < degree - 1; n++)
        {
            long double complex numerator =
                poly_function(coeffs, degree, s0[n]);
            long double complex denominator = 1.0;
            for (i = 0; i < degree - 1; i++)
                if (i != n)
                    denominator *= s0[n] - s0[i];

            delta = numerator / denominator;

            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))
            {
                printf("\n\nOverflow/underrun error - got value = %Lg",
                       cabsl(delta));
                goto end;
            }

            s0[n] -= delta;

            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));

#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "%s,", complex_str(s0[n]));
#endif
        }
        
#if defined(DEBUG) || !defined(NDEBUG)
        if (iter % 500 == 0)
        {
            printf("Iter: %lu\t", iter);
            for (n = 0; n < degree - 1; n++) printf("\t%s", complex_str(s0[n]));
            printf("\t\tabsolute average change: %.4g\n", tol_condition);
        }

        fprintf(log_file, "%.4g", tol_condition);
#endif
    }
end:

    end_time = clock();

#if defined(DEBUG) || !defined(NDEBUG)
    fclose(log_file);
#endif

    printf("\nIterations: %lu\n", iter);
    for (n = 0; n < degree - 1; n++) printf("\t%s\n", complex_str(s0[n]));
    printf("absolute average change: %.4g\n", tol_condition);
    printf("Time taken: %.4g sec\n",
           (end_time - start_time) / (double)CLOCKS_PER_SEC);

    free(coeffs);
    free(s0);

    return 0;
}
#include <math.h>
#include <stdio.h>

#define ARRAY_SIZE 20

void display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j <= n; j++)
        {
            printf("%.2f \t", a[i][j]);
        }
        printf("\n");
    }
}

float interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp[ARRAY_SIZE][ARRAY_SIZE];
    float max = fabs(m[i][i]);
    int j, k = i;

    for (j = i; j < n; j++)
    {
        if (max < fabs(m[j][i]))
        {
            max = fabs(m[j][i]);
            k = j;
        }
    }
    for (j = 0; j <= n; j++)
    {
        tmp[i][j] = m[i][j];
        m[i][j] = m[k][j];
        m[k][j] = tmp[i][j];
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
float eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp;
    int k = 1, l, j;
    for (j = i; j < n - 1; j++)
    {
        tmp = -((m[i + k][i]) / (m[i][i]));
        for (l = 0; l <= n; l++)
        {
            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);
        }
        k++;
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
int main(void)
{
    int i, j, n, k = 0, l;
    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,
        ans[ARRAY_SIZE];

    printf("Total No.of Equations : ");
    scanf("%d", &n);

    printf("\n");
    for (i = 0; i < n; i++)
    {
        printf("Enter Co-efficient Of Equations %d & Total --->>>\n", i + 1);
        for (j = 0; j <= n; j++)
        {
            printf("r%d%d : ", i, j);
            scanf("%f", &m[i][j]);
        }
        printf("\n");
    }
    printf(":::::::::::: Current Matrix ::::::::::::\n\n");
    display(m, n);

    for (i = 0; i < n - 1; i++)
    {
        printf("\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\n", i + 1);
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);
        display(m, n);
        printf("\n_______________________________________\n");
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);
        display(m, n);
    }
    printf("\n\n Values are : \n");
    for (i = n - 1; i >= 0; i--)
    {
        l = n - 1;
        mul = 0;
        for (j = 0; j < k; j++)
        {
            mul = mul + m[i][l] * ans[l];
            l--;
        }
        k++;
        ans[i] = (m[i][n] - mul) / m[i][i];
        printf("X%d = %.2f\n", i + 1, ans[i]);
    }

    return 0;
}
#include <math.h>
#include <stdio.h>

int main()
{
    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;

    printf("Enter values of eq1:");
    scanf("%f%f%f%f", &a1, &a2, &a3, &d1);
    printf("Enter values of eq2:");
    scanf("%f%f%f%f", &b1, &b2, &b3, &d2);
    printf("Enter values of eq3:");
    scanf("%f%f%f%f", &c1, &c2, &c3, &d3);
    x1 = x2 = x3 = 0.0;
    do
    {
        a = x1;
        b = x2;
        c = x3;
        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));
        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));
        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));
    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&
             fabs(x3 - c) > 0.0001);
    printf("x1=%f\nx2=%f\nx3=%f", x1, x2, x3);

    return 0;
}#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float x[20], y[20], a, sum, p;
    int n, i, j;

    printf("Enter the no of entry to insert->");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        printf("enter the value of x%d->", i);
        scanf("%f", &x[i]);
        printf("enter the value of y%d->", i);
        scanf("%f", &y[i]);
    }
    printf("\n X \t\t Y \n");
    printf("----------------------------\n");
    for (i = 0; i < n; i++)
    {
        printf("%f\t", x[i]);
        printf("%f\n", y[i]);
    }
    printf("\nenter the value of x for interpolation:");
    scanf("%f", &a);
    sum = 0;
    for (i = 0; i < n; i++)
    {
        p = 1.0;
        for (j = 0; j < n; j++)
        {
            if (i != j)
            {
                p = p * (a - x[j]) / (x[i] - x[j]);
            }
            sum = sum + y[i] * p;
        }
        printf("ans is->%f", sum);

        return 0;
    }
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif


int lu_decomposition(double **A, double **L, double **U, int mat_size)
{
    int row, col, j;

        for (row = 0; row < mat_size; row++)
    {
        #ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
                        double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];

                        U[row][col] = A[row][col] - lu_sum;
        }

        #ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            if (row == col)
            {
                L[row][col] = 1.;
                continue;
            }

                        double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];

                        L[col][row] = (A[col][row] - lu_sum) / U[row][row];
        }
    }

    return 0;
}


void display(double **A, int N)
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            printf("% 3.3g \t", A[i][j]);
        }
        putchar('\n');
    }
}


int main(int argc, char **argv)
{
    int mat_size = 3;      const int range = 10;
    const int range2 = range >> 1;

    if (argc == 2)
        mat_size = atoi(argv[1]);

    srand(time(NULL));  
    
    double **A = (double **)malloc(mat_size * sizeof(double *));
    double **L = (double **)malloc(mat_size * sizeof(double *));      double **U = (double **)malloc(mat_size * sizeof(double *));      for (int i = 0; i < mat_size; i++)
    {
                A[i] = (double *)calloc(mat_size, sizeof(double));
        L[i] = (double *)calloc(mat_size, sizeof(double));
        U[i] = (double *)calloc(mat_size, sizeof(double));
        for (int j = 0; j < mat_size; j++)
            
            A[i][j] = (double)(rand() % range - range2);
    }

    lu_decomposition(A, L, U, mat_size);

    printf("A = \n");
    display(A, mat_size);
    printf("\nL = \n");
    display(L, mat_size);
    printf("\nU = \n");
    display(U, mat_size);

    
    for (int i = 0; i < mat_size; i++)
    {
        free(A[i]);
        free(L[i]);
        free(U[i]);
    }
    free(A);
    free(L);
    free(U);

    return 0;
}#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LEN INT_MAX

int main(int argc, char **argv)
{
    int *a, n = 10, i, j, temp, sum = 0;
    float mean;

    if (argc == 2)
    {
        n = atoi(argv[1]);
        if (n >= MAX_LEN)
        {
            fprintf(stderr, "Maximum %d!\n", MAX_LEN);
            return 1;
        }
        a = (int *)malloc(n * sizeof(int));
    }

    printf("Random Numbers Generated are : ");
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
        printf("%2d, ", a[i]);
    }
    putchar('\n');

    for (i = 0; i < n; i++) sum = sum + a[i];

    mean = sum / (float)n;
    printf("\nMean :");
    printf("%f", mean);

    free(a);
    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float mean, median;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }

    if (n % 2 == 0)
    {
        median = (a[n / 2] + a[(n / 2) - 1]) / 2;
    }
    else
    {
        median = a[n / 2];
    }
    printf("\nMedian is : %f", median);

    return 0;
}


#include <complex.h> 
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ACCURACY 1e-10 


double complex func(double complex x)
{
    return x * x - 3.; 
    }


double complex d_func(double complex x) { return 2. * x; }


int main(int argc, char **argv)
{
    double delta = 1;
    double complex cdelta = 1;

    
    srand(time(NULL));

    
    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;

    unsigned long counter = 0;
    
    while (delta > ACCURACY && counter < ULONG_MAX)
    {
        cdelta = func(root) / d_func(root);
        root += -cdelta;
        counter++;
        delta = fabs(cabs(cdelta));

#if defined(DEBUG) || !defined(NDEBUG)
        if (counter % 50 == 0)
        {
            double r = creal(root);
            double c = cimag(root);

            printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter,
                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);
        }
#endif
    }

    double r = creal(root);
    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);

    printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter, r,
           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);

    return 0;
}


#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 


void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;           dy[0] = y[1];                       dy[1] = -omega * omega * y[0];  }


void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}


void forward_euler_step(const double dx, const double *x, double *y, double *dy)
{
    int o;
    problem(x, y, dy);
    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}


double forward_euler(double dx, double x0, double x_max, double *y,
                     char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("forward_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    
    clock_t t1 = clock();
    double x = x0;
    do      {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          forward_euler_step(dx, &x, y, dy);          x += dx;                                } while (x <= x_max);      
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}


int main(int argc, char *argv[])
{
    double X0 = 0.f;          
    double X_MAX = 10.F;      
    double Y0[] = {1.f, 0.f}; 
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
                step_size = atof(argv[1]);

        double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}


#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 


void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;           dy[0] = y[1];                       dy[1] = -omega * omega * y[0];  }


void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}


void midpoint_euler_step(double dx, double *x, double *y, double *dy)
{
    problem(x, y, dy);
    double tmp_x = (*x) + 0.5 * dx;
    double tmp_y[order];
    int o;
    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];

    problem(&tmp_x, tmp_y, dy);

    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}


double midpoint_euler(double dx, double x0, double x_max, double *y,
                      char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("midpoint_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    
    clock_t t1 = clock();
    double x = x0;
    do      {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          midpoint_euler_step(dx, &x, y, dy);          x += dx;                                 } while (x <= x_max);      
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}


int main(int argc, char *argv[])
{
    double X0 = 0.f;          
    double X_MAX = 10.F;      
    double Y0[] = {1.f, 0.f}; 
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
                step_size = atof(argv[1]);

        double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}


#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 


void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;           dy[0] = y[1];                       dy[1] = -omega * omega * y[0];  }


void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}


void semi_implicit_euler_step(double dx, double *x, double *y, double *dy)
{
    int o;

    problem(x, y, dy);       y[0] += dx * dy[0];  
    problem(x, y, dy);  
    for (o = 1; o < order; o++)
        y[o] += dx * dy[o];      *x += dx;
}


double semi_implicit_euler(double dx, double x0, double x_max, double *y,
                           char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("semi_implicit_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    
    clock_t t1 = clock();
    double x = x0;
    do      {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          semi_implicit_euler_step(dx, &x, y, dy);          x += dx;                                      } while (x <= x_max);      
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}


int main(int argc, char *argv[])
{
    double X0 = 0.f;          
    double X_MAX = 10.F;      
    double Y0[] = {1.f, 0.f}; 
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
                step_size = atof(argv[1]);

        double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);          exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}


#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "qr_decompose.h"


int main(void)
{
    double **A;
    unsigned int ROWS, COLUMNS;

    printf("Enter the number of rows and columns: ");
    scanf("%u %u", &ROWS, &COLUMNS);
    if (ROWS < COLUMNS)
    {
        fprintf(stderr,
                "Number of rows must be greater than or equal to "
                "number of columns.\n");
        return -1;
    }

    printf("Enter matrix elements row-wise:\n");

    A = (double **)malloc(ROWS * sizeof(double *));
    for (int i = 0; i < ROWS; i++)
        A[i] = (double *)malloc(COLUMNS * sizeof(double));

    for (int i = 0; i < ROWS; i++)
        for (int j = 0; j < COLUMNS; j++) scanf("%lf", &A[i][j]);

    print_matrix(A, ROWS, COLUMNS);

    double **R = (double **)malloc(sizeof(double *) * ROWS);
    double **Q = (double **)malloc(sizeof(double *) * ROWS);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        return -1;
    }
    for (int i = 0; i < ROWS; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * COLUMNS);
        Q[i] = (double *)malloc(sizeof(double) * ROWS);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            return -1;
        }
    }

    clock_t t1 = clock();
    qr_decompose(A, Q, R, ROWS, COLUMNS);
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    print_matrix(R, ROWS, COLUMNS);
    print_matrix(Q, ROWS, COLUMNS);
    printf("Time taken to compute: %.4g sec\n", dtime);

    for (int i = 0; i < ROWS; i++)
    {
        free(A[i]);
        free(R[i]);
        free(Q[i]);
    }
    free(A);
    free(R);
    free(Q);
    return 0;
}

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "qr_decompose.h"
#ifdef _OPENMP
#include <omp.h>
#endif

#define LIMS 9        
#define EPSILON 1e-10 


void create_matrix(double **A, int N)
{
    int i, j, tmp, lim2 = LIMS >> 1;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        A[i][i] = (rand() % LIMS) - lim2;
        for (j = i + 1; j < N; j++)
        {
            tmp = (rand() % LIMS) - lim2;
            A[i][j] = tmp;
            A[j][i] = tmp;
        }
    }
}


double **mat_mul(double **A, double **B, double **OUT, int R1, int C1, int R2,
                 int C2)
{
    if (C1 != R2)
    {
        perror("Matrix dimensions mismatch!");
        return OUT;
    }

    int i;
#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < R1; i++)
    {
        for (int j = 0; j < C2; j++)
        {
            OUT[i][j] = 0.f;
            for (int k = 0; k < C1; k++) OUT[i][j] += A[i][k] * B[k][j];
        }
    }
    return OUT;
}


double eigen_values(double **A, double *eigen_vals, int mat_size,
                    char debug_print)
{
    if (!eigen_vals)
    {
        perror("Output eigen value vector cannot be NULL!");
        return -1;
    }
    double **R = (double **)malloc(sizeof(double *) * mat_size);
    double **Q = (double **)malloc(sizeof(double *) * mat_size);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        if (Q)
        {
            free(Q);
        }
        if (R)
        {
            free(R);
        }
        return -1;
    }

    
    for (int i = 0; i < mat_size; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * mat_size);
        Q[i] = (double *)malloc(sizeof(double) * mat_size);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            for (; i >= 0; i--)
            {
                free(R[i]);
                free(Q[i]);
            }
            free(Q);
            free(R);
            return -1;
        }
    }

    if (debug_print)
    {
        print_matrix(A, mat_size, mat_size);
    }

    int rows = mat_size, columns = mat_size;
    int counter = 0, num_eigs = rows - 1;
    double last_eig = 0;

    clock_t t1 = clock();
    while (num_eigs > 0) 
    {
        
        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)
        {
            last_eig = A[num_eigs][num_eigs];
            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; 
            qr_decompose(A, Q, R, rows, columns);

            if (debug_print)
            {
                print_matrix(A, rows, columns);
                print_matrix(Q, rows, columns);
                print_matrix(R, columns, columns);
                printf("-------------------- %d ---------------------\n",
                       ++counter);
            }

            mat_mul(R, Q, A, columns, columns, rows, columns);
            for (int i = 0; i < rows; i++) A[i][i] += last_eig; 
        }

        
        eigen_vals[num_eigs] = last_eig;

        if (debug_print)
        {
            printf("========================\n");
            printf("Eigen value: % g,\n", last_eig);
            printf("========================\n");
        }

        num_eigs--;
        rows--;
        columns--;
    }
    eigen_vals[0] = A[0][0];
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    if (debug_print)
    {
        print_matrix(R, mat_size, mat_size);
        print_matrix(Q, mat_size, mat_size);
    }

    
    for (int i = 0; i < mat_size; i++)
    {
        free(R[i]);
        free(Q[i]);
    }
    free(R);
    free(Q);

    return dtime;
}


void test1()
{
    int mat_size = 2;
    double X[][2] = {{5, 7}, {7, 11}};
    double y[] = {15.56158, 0.384227};      double eig_vals[2] = {0, 0};

        double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 1 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

                assert(result != 0);
        printf("found\n");
    }
    printf("Test 1 Passed in %.3g sec\n\n", dtime);
    free(A);
}


void test2()
{
    int mat_size = 5;
    double X[][5] = {{-4, 4, 2, 0, -3},
                     {4, -4, 4, -3, -1},
                     {2, 4, 4, 3, -3},
                     {0, -3, 3, -1, -3},
                     {-3, -1, -3, -3, 0}};
    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,
                  -5.98994};      double eig_vals[5];

        double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 2 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

                assert(result != 0);
        printf("found\n");
    }
    printf("Test 2 Passed in %.3g sec\n\n", dtime);
    free(A);
}


int main(int argc, char **argv)
{
    srand(time(NULL));

    int mat_size = 5;
    if (argc == 2)
    {
        mat_size = atoi(argv[1]);
    }
    else
    {          test1();
        test2();
        printf("Usage: ./qr_eigen_values [mat_size]\n");
        return 0;
    }

    if (mat_size < 2)
    {
        fprintf(stderr, "Matrix size should be > 2\n");
        return -1;
    }

    int i;

    double **A = (double **)malloc(sizeof(double *) * mat_size);
    
    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);
    if (!eigen_vals)
    {
        perror("Unable to allocate memory for eigen values!");
        free(A);
        return -1;
    }
    for (i = 0; i < mat_size; i++)
    {
        A[i] = (double *)malloc(sizeof(double) * mat_size);
        eigen_vals[i] = 0.f;
    }

    
    create_matrix(A, mat_size);

    print_matrix(A, mat_size, mat_size);

    double dtime = eigen_values(A, eigen_vals, mat_size, 0);
    printf("Eigen vals: ");
    for (i = 0; i < mat_size; i++) printf("% 9.4g\t", eigen_vals[i]);
    printf("\nTime taken to compute: % .4g sec\n", dtime);

    for (int i = 0; i < mat_size; i++) free(A[i]);
    free(A);
    free(eigen_vals);
    return 0;
}

#include <assert.h>
#include <math.h>
#include <stdio.h>


void stats_computer1(float x, float *mean, float *variance, float *std)
{
    
    static unsigned int n = 0;
    static float Ex = 0.f, Ex2 = 0.f;
    static float K = 0.f;

    if (n == 0)
        K = x;
    n++;
    float tmp = x - K;
    Ex += tmp;
    Ex2 += tmp * tmp;

    
    if (mean != NULL)
        *mean = K + Ex / n;

    
    if (variance != NULL)
        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);

    
    if (std != NULL)
        *std = sqrtf(*variance);
}


void stats_computer2(float x, float *mean, float *variance, float *std)
{
    
    static unsigned int n = 0;
    static float mu = 0, M = 0;

    n++;
    float delta = x - mu;
    mu += delta / n;
    float delta2 = x - mu;
    M += delta * delta2;

    
    if (mean != NULL)
        *mean = mu;

    
    if (variance != NULL)
        *variance = M / n;

    
    if (std != NULL)
        *std = sqrtf(*variance);
}


void test_function(const float *test_data, const int number_of_samples)
{
    float ref_mean = 0.f, ref_variance = 0.f;
    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    for (int i = 0; i < number_of_samples; i++)
    {
        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);
        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);
        ref_mean += test_data[i];
    }
    ref_mean /= number_of_samples;

    for (int i = 0; i < number_of_samples; i++)
    {
        float temp = test_data[i] - ref_mean;
        ref_variance += temp * temp;
    }
    ref_variance /= number_of_samples;

    printf("<<<<<<<< Test Function >>>>>>>>\n");
    printf("Expected: Mean: %.4f\t Variance: %.4f\n", ref_mean, ref_variance);
    printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s1_mean,
           s1_variance, s1_std);
    printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s2_mean,
           s2_variance, s2_std);

    assert(fabs(s1_mean - ref_mean) < 0.01);
    assert(fabs(s2_mean - ref_mean) < 0.01);
    assert(fabs(s2_variance - ref_variance) < 0.01);

    printf("(Tests passed)\n\n");
}


int main(int argc, char **argv)
{
    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};
    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));

    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    printf("Enter data. Any non-numeric data will terminate the data input.\n");

    while (1)
    {
        float val;
        printf("Enter number: ");

                        if (!scanf("%f", &val))
            break;

        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);
        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);

        printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s1_mean, s1_variance, s1_std);
        printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s2_mean, s2_variance, s2_std);
    }

    return 0;
}
#include <math.h>
#include <stdio.h>

float f(float x)
{
    return 1.0 +
           x * x * x;  }

int main()
{
    int i, n;
    float a, b, h, x, s2, s3, sum, integral;

    printf("enter the lower limit of the integration:");
    scanf("%f", &a);
    printf("enter the upper limit of the integration:");
    scanf("%f", &b);
    printf("enter the number of intervals:");
    scanf("%d", &n);

    h = (b - a) / n;
    sum = f(a) + f(b);
    s2 = s3 = 0.0;

    for (i = 1; i < n; i += 3)
    {
        x = a + i * h;
        s3 = s3 + f(x) + f(x + h);
    }

    for (i = 3; i < n; i += 3)
    {
        x = a + i * h;
        s2 = s2 + f(x);
    }

    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);
    printf("\nValue of the integral = %9.4f\n", integral);

    return 0;
}#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;
    float MEAN = 0, VARIANCE = 0, STAND;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &ARRAY_LENGTH);
    ARRAY = (int *)realloc(
        ARRAY,
        ARRAY_LENGTH * (sizeof(int)));      for (i = 0; i < ARRAY_LENGTH; i++)          ARRAY[i] = rand() % 100;

    printf("Random Numbers Generated are :\n");      for (i = 0; i < ARRAY_LENGTH; i++) printf("%d ", ARRAY[i]);

    printf("\nSorted Data: ");  
    while (!isSorted)
    {                          isSorted = 1;          for (i = 0; i < ARRAY_LENGTH - 1; i++)
        {              if (ARRAY[i] > ARRAY[i + 1])
            {                                  isSorted = 0;                  TEMPORARY_ELEMENT = ARRAY[i];                                                                 ARRAY[i] = ARRAY[i + 1];
                ARRAY[i + 1] = TEMPORARY_ELEMENT;
            }
        }
    }
    for (i = 0; i < ARRAY_LENGTH; i++)
    {
        printf("%d ", ARRAY[i]);
        MEAN = MEAN + ARRAY[i];
    }
    MEAN = MEAN / (float)ARRAY_LENGTH;

    for (i = 0; i < ARRAY_LENGTH; i++)
        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));

    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;
    STAND = sqrt(VARIANCE);

    printf("\n\n- Mean is: %f\n", MEAN);
    printf("- Variance is: %f\n", VARIANCE);
    printf("- Standard Deviation is: %f\n", STAND);
}

#include <assert.h>
#include <stdio.h>


int binarysearch1(const int *arr, int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;

                if (arr[mid] == x)
            return mid;

                if (arr[mid] > x)
            return binarysearch1(arr, l, mid - 1, x);

                return binarysearch1(arr, mid + 1, r, x);
    }

        return -1;
}


int binarysearch2(const int *arr, int l, int r, int x)
{
    int mid = l + (r - l) / 2;

    while (arr[mid] != x)
    {
        if (r <= l || r < 0)
            return -1;

        if (arr[mid] > x)
                        r = mid - 1;
        else
                        l = mid + 1;

        mid = l + (r - l) / 2;
    }

        return mid;
}


void test()
{
        int arr[] = {2, 3, 4, 10, 40};
        int n = sizeof(arr) / sizeof(arr[0]);

    printf("Test 1.... ");
        int x = 10;
        int result = binarysearch1(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed iterative...\n");

    printf("Test 2.... ");
    x = 5;
        result = binarysearch1(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed iterative...\n");
}


int main(void)
{
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int fibMonaccianSearch(int arr[], int x, int n)
{
    
    int fibMMm2 = 0;                   int fibMMm1 = 1;                   int fibM = fibMMm2 + fibMMm1;  
    
    while (fibM < n)
    {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }

        int offset = -1;

    
    while (fibM > 1)
    {
        
                int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);

        
        if (arr[i] < x)
        {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        }

        
        else if (arr[i] > x)
        {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        }

        
        else
            return i;
    }

    
    if (fibMMm1 && arr[offset + 1] == x)
        return offset + 1;

    
    return -1;
}

int main(void)
{
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 85;
    printf("Found at index: %d", fibMonaccianSearch(arr, x, n));
    return 0;
}
#include <stdio.h>



int interpolationSearch(int arr[], int n, int key)
{
    int low = 0, high = n - 1;
    while (low <= high && key >= arr[low] && key <= arr[high])
    {
        
        int pos =
            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        if (key > arr[pos])
            low = pos + 1;
        else if (key < arr[pos])
            high = pos - 1;
        else 
            return pos;
    }
    
    return -1;
}

int main()
{
    int x;
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\nEnter the number to be searched: ");
    scanf("%d", &x); 

    int index = interpolationSearch(arr, n, x);

    
    if (index != -1)
        printf("Element found at position: %d\n", index);
    else
        printf("Element not found.\n");
    return 0;
}

#include <assert.h>
#include <math.h>
#include <stdio.h>


#define min(X, Y) ((X) < (Y) ? (X) : (Y))


int jump_search(const int *arr, int x, size_t n)
{
    int step = floor(sqrt(n));
    int prev = 0;

    while (arr[min(step, n) - 1] < x)
    {
        prev = step;
        step += floor(sqrt(n));
        if (prev >= n)
        {
            return -1;
        }
    }

    while (arr[prev] < x)
    {
        prev = prev + 1;
        if (prev == min(step, n))
        {
            return -1;
        }
    }
    if (arr[prev] == x)
    {
        return prev;
    }
    return -1;
}


void test()
{
    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
    size_t n = sizeof(arr) / sizeof(int);

    int x = 55;
    printf("Test 1.... ");
    int index = jump_search(arr, x, n);
    assert(index == 10);
    printf("passed\nTest 2.... ");
    x = 56;
    index = jump_search(arr, x, n);
    assert(index == -1);
    printf("passed\nTest 3.... ");
    x = 13;
    index = jump_search(arr, x, n);
    assert(index == 7);
    printf("passed\n");
}


int main()
{
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int linearsearch(int *arr, int size, int val)
{
    int i;
    for (i = 0; i < size; i++)
    {
        if (arr[i] == val)
            return 1;
    }
    return 0;
}

int main()
{
    int n, i, v;
    printf("Enter the size of the array:\n");
    scanf("%d", &n);  
    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter the contents for an array of size %d:\n", n);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i]);                               
    printf("Enter the value to be searched:\n");
    scanf("%d", &v);      if (linearsearch(a, n, v))
        printf("Value %d is in the array.\n", v);
    else
        printf("Value %d is not in the array.\n", v);

    free(a);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>


int binarySearch(const int **mat, int i, int j_low, int j_high, int x)
{
    while (j_low <= j_high)
    {
        int j_mid = (j_low + j_high) / 2;

                if (mat[i][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i, j_mid);
            return j_mid;
        }
        else if (mat[i][j_mid] > x)
            j_high = j_mid - 1;
        else
            j_low = j_mid + 1;
    }

        printf("element not found\n");
    return -1;
}


void modifiedBinarySearch(const int **mat, int n, int m, int x)
{      if (n == 1)
    {
        binarySearch(mat, 0, 0, m - 1, x);
        return;
    }

            int i_low = 0, i_high = n - 1, j_mid = m / 2;
    while ((i_low + 1) < i_high)
    {
        int i_mid = (i_low + i_high) / 2;
                if (mat[i_mid][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i_mid, j_mid);
            return;
        }
        else if (mat[i_mid][j_mid] > x)
            i_high = i_mid;
        else
            i_low = i_mid;
    }
        if (mat[i_low][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low, j_mid);
    else if (mat[i_low + 1][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low + 1, j_mid);

        else if (x <= mat[i_low][j_mid - 1])
        binarySearch(mat, i_low, 0, j_mid - 1, x);

        else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])
        binarySearch(mat, i_low, j_mid + 1, m - 1, x);

        else if (x <= mat[i_low + 1][j_mid - 1])
        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);

        else
        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);
}


int main()
{
    int x;         int m, n;  
    scanf("%d %d %d\n", &n, &m, &x);

    int **mat = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &mat[i][j]);
        }
    }

    modifiedBinarySearch(mat, n, m, x);

    for (int i = 0; i < n; i++) free(mat[i]);
    free(mat);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define len 5

int binarySearch(int array[], int leng, int searchX)
{
    int pos = -1, right, left, i = 0;

    left = 0;
    right = leng - 1;

    while (left <= right)
    {
        pos = left + (right - left) / 2;
        if (array[pos] == searchX)
        {
            return pos;
        }
        else if (array[pos] > searchX)
        {
            right = pos - 1;
        }
        else
        {
            left = pos + 1;
        }
    }
    return -1; 
}

int main(int argc, char *argv[])
{
    int array[len] = {5, 8, 10, 14, 16};

    int position;
    position = binarySearch(array, len, 5);

    if (position < 0)
        printf("The number %d doesnt exist in array\n", 5);
    else
    {
        printf("The number %d exist in array at position : %d \n", 5, position);
    }

    return 0;
}

#include <stdio.h>

int ternarySearch(int l, int r, int key, int ar[])
{
    if (r >= l)
    {
                int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;

                if (ar[mid1] == key)
        {
            return mid1;
        }
        if (ar[mid2] == key)
        {
            return mid2;
        }

                                
        if (key < ar[mid1])
        {
                        return ternarySearch(l, mid1 - 1, key, ar);
        }
        else if (key > ar[mid2])
        {
                        return ternarySearch(mid2 + 1, r, key, ar);
        }
        else
        {
                        return ternarySearch(mid1 + 1, mid2 - 1, key, ar);
        }
    }

        return -1;
}

int main()
{
    int l, r, p, key;

            int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        l = 0;

        r = 9;

    
        key = 5;

        p = ternarySearch(l, r, key, ar);

        printf("Index of %d is %d\n", key, p);

    
        key = 50;

        p = ternarySearch(l, r, key, ar);

        printf("Index of %d is %d", key, p);
}
#include <stdio.h>
#include <stdlib.h>



#define BEAD(i, j) beads[i * max + j]


void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}


void bead_sort(int *a, size_t len)
{
    int i, j, max, sum;
    unsigned char *beads;

    for (i = 1, max = a[0]; i < len; i++)
        if (a[i] > max)
            max = a[i];

    beads = calloc(1, max * len);

    
    for (i = 0; i < len; i++)
        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;

    for (j = 0; j < max; j++)
    {
        
        for (sum = i = 0; i < len; i++)
        {
            sum += BEAD(i, j);
            BEAD(i, j) = 0;
        }
        
        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
    }

    for (i = 0; i < len; i++)
    {
        for (j = 0; j < max && BEAD(i, j); j++)
            ;
        a[i] = j;
    }
    free(beads);
}



int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    bead_sort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>


void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int binarySearch(int *arr, int key, int low, int high)
{
    if (low >= high)
        return (key > arr[low]) ? (low + 1) : low;
    int mid = low + (high - 1) / 2;
    if (arr[mid] == key)
        return mid + 1;
    else if (arr[mid] > key)
        return binarySearch(arr, key, low, mid - 1);
    else
        return binarySearch(arr, key, mid + 1, high);
}

void insertionSort(int *arr, int size)
{
    int i, j, key, index;
    for (i = 0; i < size; i++)
    {
        j = i - 1;
        key = arr[i];
        
        index = binarySearch(arr, key, 0, j);
        
        while (j >= index)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        
        arr[j + 1] = key;
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool check_sorted(int *a, int n)
{
    while (--n >= 1)
    {
        if (a[n] < a[n - 1])
            return false;
    }
    return true;
}

void shuffle(int *a, int n)
{
    int i, t, r;
    for (i = 0; i < n; i++)
    {
        t = a[i];
        r = rand() % n;
        a[i] = a[r];
        a[r] = t;
    }
}

void sort(int *a, int n)
{
    while (!check_sorted(a, n)) shuffle(a, n);
}

int main()
{
    int numbers[6];
    int i;
    printf("Enter 6 numbers unsorted \n\n");
    for (i = 0; i < 6; i++)
    {
        scanf("%d", &numbers[i]);
    }
    sort(numbers, 6);
    for (i = 0; i < 6; i++) printf("%d ", numbers[i]);
    printf("\n");
}
#include <stdio.h>
#include <stdlib.h>


void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}


void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}


void bubbleSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        for (int j = 0; j < size - 1 - i; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  
    bubbleSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);  
    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define MAX 20
#define TRUE 1
#define FALSE 0

int main()
{
    int i, arraySort[MAX] = {0}, isSort = FALSE, changePlace;

    

    for (i = 0; i < MAX; i++)
    {
        arraySort[i] = rand() % 101;
    }

    

    while (isSort)
    {
        isSort = FALSE;

        for (i = 0; i < MAX - 1; i++)
        {
            if (arraySort[i] > arraySort[i + 1])
            {
                changePlace = arraySort[i];
                arraySort[i] = arraySort[i + 1];
                arraySort[i + 1] = changePlace;
                isSort = TRUE;
            }
        }
    }

    

    for (i = 0; i < MAX; i++)
    {
        printf("%d\n", arraySort[i]);
    }

    return EXIT_SUCCESS;
}

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#define NARRAY 8    
#define NBUCKET 5   
#define INTERVAL 10 

struct Node
{
    int data;
    struct Node *next;
};

void BucketSort(int arr[]);
struct Node *InsertionSort(struct Node *list);
void print(int arr[]);
void printBuckets(struct Node *list);
int getBucketIndex(int value);

void BucketSort(int arr[])
{
    int i, j;
    struct Node **buckets;

    
    buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);

    
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = NULL;
    }

    
    
    for (i = 0; i < NARRAY; ++i)
    {
        struct Node *current;
        int pos = getBucketIndex(arr[i]);
        current = (struct Node *)malloc(sizeof(struct Node));
        current->data = arr[i];
        current->next = buckets[pos];
        buckets[pos] = current;
    }

    
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = InsertionSort(buckets[i]);
    }

    
    printf("--------------\n");
    printf("Buckets after sorted\n");
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    
    for (j = 0, i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
                        assert(j < NARRAY);
            arr[j++] = node->data;
            node = node->next;
        }
    }

    
    for (i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
            struct Node *tmp;
            tmp = node;
            node = node->next;
            free(tmp);
        }
    }
    free(buckets);
    return;
}


struct Node *InsertionSort(struct Node *list)
{
    struct Node *k, *nodeList;
    
    if (list == NULL || list->next == NULL)
    {
        return list;
    }

    nodeList = list;
    k = list->next;
    nodeList->next = NULL; 
    while (k != NULL)
    {
        struct Node *ptr;
        
        if (nodeList->data > k->data)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;              tmp->next = nodeList;
            nodeList = tmp;
            continue;
        }

                        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)
        {
            if (ptr->next->data > k->data)
                break;
        }

                if (ptr->next != NULL)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;              tmp->next = ptr->next;
            ptr->next = tmp;
            continue;
        }
        else
        {
            ptr->next = k;
            k = k->next;              ptr->next->next = NULL;
            continue;
        }
    }
    return nodeList;
}

int getBucketIndex(int value) { return value / INTERVAL; }

void print(int ar[])
{
    int i;
    for (i = 0; i < NARRAY; ++i)
    {
        printf("%d ", ar[i]);
    }
    printf("\n");
}

void printBuckets(struct Node *list)
{
    struct Node *cur = list;
    while (cur)
    {
        printf("%d ", cur->data);
        cur = cur->next;
    }
}

int main(void)
{
    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};

    printf("Initial array\n");
    print(array);
    printf("------------\n");

    BucketSort(array);
    printf("------------\n");
    printf("Sorted array\n");
    print(array);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

void cocktailSort(int arr[], int size)
{
    int i, changed = TRUE, temp, start = 0, end = size - 1;

    while (changed)
    {
        changed = FALSE;
        for (i = start; i < end; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                changed = TRUE;
            }
        }
        end--;

        if (changed == FALSE)
        {
            break;
        }
        changed = FALSE;

        for (i = end - 1; i >= start; i--)
        {
            if (arr[i + 1] < arr[i])
            {
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
                changed = TRUE;
            }
        }
        start++;
    }
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    cocktailSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}#include <stdio.h>
#include <stdlib.h>
#define SHRINK 1.3  
void sort(int *numbers, int size)
{
    int gap = size;
    while (gap > 1)      {
        gap = gap / SHRINK;
        int i = 0;
        while ((i + gap) < size)
        {              if (numbers[i] > numbers[i + gap])
            {
                int tmp = numbers[i];
                numbers[i] = numbers[i + gap];
                numbers[i + gap] = tmp;
            }
            i++;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    int i;
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int i, n, l = 0;

    printf("Enter size of array = ");
    scanf("%d", &n);

    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter %d elements in array :\n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
        if (a[i] > l)
            l = a[i];
    }

    int *b = (int *)malloc((l + 1) * sizeof(int));
    memset(b, 0, (l + 1) * sizeof(b[0]));

    for (i = 0; i < n; i++) b[a[i]]++;  
    for (i = 0; i < (l + 1); i++)      {
        if (b[i] > 0)
        {
            while (b[i] != 0)              {
                printf("%d ", i);
                b[i]--;
            }
        }
    }

    free(a);
    free(b);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

void cycleSort(int *arr, int n)
{
        int writes = 0;

            for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)
    {
                int item = arr[cycle_start];

                        int pos = cycle_start;
        for (int i = cycle_start + 1; i < n; i++)
            if (arr[i] < item)
                pos++;

                if (pos == cycle_start)
            continue;

                while (item == arr[pos]) pos += 1;

                if (pos != cycle_start)
        {
            swap(&item, &arr[pos]);
            writes++;
        }

                while (pos != cycle_start)
        {
            pos = cycle_start;

                        for (int i = cycle_start + 1; i < n; i++)
                if (arr[i] < item)
                    pos += 1;

                        while (item == arr[pos]) pos += 1;

                        if (item != arr[pos])
            {
                swap(&item, &arr[pos]);
                writes++;
            }
        }
    }
}

int main()
{
    int n;  
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    cycleSort(arr, n);
    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void sort(int *numbers, int size)
{
    int pos = 0;
    while (pos < size)
    {
        if (numbers[pos] >= numbers[pos - 1])
            pos++;
        else
        {
            int tmp = numbers[pos - 1];
            numbers[pos - 1] = numbers[pos];
            numbers[pos] = tmp;
            pos--;

            if (pos == 0)
                pos = 1;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int i;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}
#include <stdio.h>

void max_heapify(int *a, int i, int n);
void heapsort(int *a, int n);
void build_maxheap(int *a, int n);

void max_heapify(int *a, int i, int n)
{
    int j, temp;
    temp = a[i];
    j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j + 1] > a[j])
            j = j + 1;
        if (temp > a[j])
        {
            break;
        }
        else if (temp <= a[j])
        {
            a[j / 2] = a[j];
            j = 2 * j;
        }
    }
    a[j / 2] = temp;
    return;
}

void heapsort(int *a, int n)
{
    int i, temp;
    for (i = n; i >= 2; i--)
    {
        temp = a[i];
        a[i] = a[1];
        a[1] = temp;
        max_heapify(a, 1, i - 1);
    }
}

void build_maxheap(int *a, int n)
{
    int i;
    for (i = n / 2; i >= 1; i--)
    {
        max_heapify(a, i, n);
    }
}

int main()
{
    int n, i;
    printf("Enter number of elements of array\n");
    scanf("%d", &n);
    int a[20];
    for (i = 1; i <= n; i++)
    {
        printf("Enter Element %d\n", i);
        scanf("%d", a + i);
    }

    build_maxheap(a, n);
    heapsort(a, n);
    printf("Sorted Output\n");
    for (i = 1; i <= n; i++)
    {
        printf("%d\n", a[i]);
    }

    getchar();
}
#include <stdio.h>
#include <stdlib.h>


void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}


void insertionSort(int *arr, int size)
{
    int i, j, key;
    for (i = 0; i < size; i++)
    {
        j = i - 1;
        key = arr[i];
        
        while (j >= 0 && key < arr[j])
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        
        arr[j + 1] = key;
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>



void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}


void merge(int *a, int l, int r, int n)
{
    int *b = (int *)malloc(n * sizeof(int)); 
    int c = l;
    int p1, p2;
    p1 = l;
    p2 = ((l + r) / 2) + 1;
    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))
    {
        if (a[p1] <= a[p2])
        {
            b[c++] = a[p1];
            p1++;
        }
        else
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    if (p2 == r + 1)
    {
        while ((p1 < ((l + r) / 2) + 1))
        {
            b[c++] = a[p1];
            p1++;
        }
    }
    else
    {
        while ((p2 < r + 1))
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    for (c = l; c < r - l + 1; c++) a[c] = b[c];

    free(b);
}


void merge_sort(int *a, int n, int l, int r)
{
    if (r - l == 1)
    {
        if (a[l] > a[r])
            swap(&a[l], &a[r]);
    }
    else if (l != r)
    {
        merge_sort(a, n, l, (l + r) / 2);
        merge_sort(a, n, ((l + r) / 2) + 1, r);
        merge(a, l, r, n);
    }

    
}



int main(void)
{
    int *a, n, i;
    scanf("%d", &n);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    merge_sort(a, n, 0, n - 1);
    for (i = 0; i < n; i++)
    {
        printf(" %d", a[i]);
    }

    free(a);

    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


#ifndef min
#define min(a, b) ((a) <= (b) ? (a) : (b))
#endif

#define swap(a, b)      \
    {                   \
        char *t = x[a]; \
        x[a] = x[b];    \
        x[b] = t;       \
    }
#define i2c(i) x[i][depth]

void vecswap(int i, int j, int n, char *x[])
{
    while (n-- > 0)
    {
        swap(i, j);
        i++;
        j++;
    }
}

void ssort1(char *x[], int n, int depth)
{
    int a, b, c, d, r, v;
    if (n <= 1)
        return;
    a = rand() % n;
    swap(0, a);
    v = i2c(0);
    a = b = 1;
    c = d = n - 1;
    for (;;)
    {
        while (b <= c && (r = i2c(b) - v) <= 0)
        {
            if (r == 0)
            {
                swap(a, b);
                a++;
            }
            b++;
        }
        while (b <= c && (r = i2c(c) - v) >= 0)
        {
            if (r == 0)
            {
                swap(c, d);
                d--;
            }
            c--;
        }
        if (b > c)
            break;
        swap(b, c);
        b++;
        c--;
    }
    r = min(a, b - a);
    vecswap(0, b - r, r, x);
    r = min(d - c, n - d - 1);
    vecswap(b, n - r, r, x);
    r = b - a;
    ssort1(x, r, depth);
    if (i2c(r) != 0)
        ssort1(x + r, a + n - d - 1, depth + 1);
    r = d - c;
    ssort1(x + n - r, r, depth);
}

void ssort1main(char *x[], int n) { ssort1(x, n, 0); }


void vecswap2(char **a, char **b, int n)
{
    while (n-- > 0)
    {
        char *t = *a;
        *a++ = *b;
        *b++ = t;
    }
}

#define swap2(a, b)  \
    {                \
        t = *(a);    \
        *(a) = *(b); \
        *(b) = t;    \
    }
#define ptr2char(i) (*(*(i) + depth))

char **med3func(char **a, char **b, char **c, int depth)
{
    int va, vb, vc;
    if ((va = ptr2char(a)) == (vb = ptr2char(b)))
        return a;
    if ((vc = ptr2char(c)) == va || vc == vb)
        return c;
    return va < vb ? (vb < vc ? b : (va < vc ? c : a))
                   : (vb > vc ? b : (va < vc ? a : c));
}
#define med3(a, b, c) med3func(a, b, c, depth)

void inssort(char **a, int n, int d)
{
    char **pi, **pj, *s, *t;
    for (pi = a + 1; --n > 0; pi++)
        for (pj = pi; pj > a; pj--)
        {
                        for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)
                ;
            if (*s <= *t)
                break;
            swap2(pj, pj - 1);
        }
}

void ssort2(char **a, int n, int depth)
{
    int d, r, partval;
    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;
    if (n < 10)
    {
        inssort(a, n, depth);
        return;
    }
    pl = a;
    pm = a + (n / 2);
    pn = a + (n - 1);
    if (n > 30)
    {          d = (n / 8);
        pl = med3(pl, pl + d, pl + 2 * d);
        pm = med3(pm - d, pm, pm + d);
        pn = med3(pn - 2 * d, pn - d, pn);
    }
    pm = med3(pl, pm, pn);
    swap2(a, pm);
    partval = ptr2char(a);
    pa = pb = a + 1;
    pc = pd = a + n - 1;
    for (;;)
    {
        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)
        {
            if (r == 0)
            {
                swap2(pa, pb);
                pa++;
            }
            pb++;
        }
        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)
        {
            if (r == 0)
            {
                swap2(pc, pd);
                pd--;
            }
            pc--;
        }
        if (pb > pc)
            break;
        swap2(pb, pc);
        pb++;
        pc--;
    }
    pn = a + n;
    r = min(pa - a, pb - pa);
    vecswap2(a, pb - r, r);
    r = min(pd - pc, pn - pd - 1);
    vecswap2(pb, pn - r, r);
    if ((r = pb - pa) > 1)
        ssort2(a, r, depth);
    if (ptr2char(a + r) != 0)
        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);
    if ((r = pd - pc) > 1)
        ssort2(a + n - r, r, depth);
}

void ssort2main(char **a, int n) { ssort2(a, n, 0); }


typedef struct tnode *Tptr;
typedef struct tnode
{
    char splitchar;
    Tptr lokid, eqkid, hikid;
} Tnode;
Tptr root;


Tptr insert1(Tptr p, char *s)
{
    if (p == 0)
    {
        p = (Tptr)malloc(sizeof(Tnode));
        p->splitchar = *s;
        p->lokid = p->eqkid = p->hikid = 0;
    }
    if (*s < p->splitchar)
        p->lokid = insert1(p->lokid, s);
    else if (*s == p->splitchar)
    {
        if (*s != 0)
            p->eqkid = insert1(p->eqkid, ++s);
    }
    else
        p->hikid = insert1(p->hikid, s);
    return p;
}

void cleanup1(Tptr p)
{
    if (p)
    {
        cleanup1(p->lokid);
        cleanup1(p->eqkid);
        cleanup1(p->hikid);
        free(p);
    }
}


#define BUFSIZE 1000
Tptr buf;
int bufn, freen;
void *freearr[10000];
int storestring = 0;

void insert2(char *s)
{
    int d;
    char *instr = s;

    Tptr pp, *p;
    p = &root;
    while (pp == *p)
    {
        if ((d = *s - pp->splitchar) == 0)
        {
            if (*s++ == 0)
                return;
            p = &(pp->eqkid);
        }
        else if (d < 0)
            p = &(pp->lokid);
        else
            p = &(pp->hikid);
    }
    for (;;)
    {
                if (bufn-- == 0)
        {
            buf = (Tptr)malloc(BUFSIZE * sizeof(Tnode));
            freearr[freen++] = (void *)buf;
            bufn = BUFSIZE - 1;
        }
        *p = buf++;
        pp = *p;
        pp->splitchar = *s;
        pp->lokid = pp->eqkid = pp->hikid = 0;
        if (*s++ == 0)
        {
            if (storestring)
                pp->eqkid = (Tptr)instr;
            return;
        }
        p = &(pp->eqkid);
    }
}
void cleanup2()
{
    int i;
    for (i = 0; i < freen; i++) free(freearr[i]);
}


int search1(char *s)
{
    Tptr p;
    p = root;
    while (p)
    {
        if (*s < p->splitchar)
            p = p->lokid;
        else if (*s == p->splitchar)
        {
            if (*s++ == 0)
                return 1;
            p = p->eqkid;
        }
        else
            p = p->hikid;
    }
    return 0;
}

int search2(char *s)
{
    int d, sc;
    Tptr p;
    sc = *s;
    p = root;
    while (p)
    {
        if ((d = sc - p->splitchar) == 0)
        {
            if (sc == 0)
                return 1;
            sc = *++s;
            p = p->eqkid;
        }
        else if (d < 0)
            p = p->lokid;
        else
            p = p->hikid;
    }
    return 0;
}


int nodecnt;
char *srcharr[100000];
int srchtop;

void pmsearch(Tptr p, char *s)
{
    if (!p)
        return;
    nodecnt++;
    if (*s == '.' || *s < p->splitchar)
        pmsearch(p->lokid, s);
    if (*s == '.' || *s == p->splitchar)
        if (p->splitchar && *s)
            pmsearch(p->eqkid, s + 1);
    if (*s == 0 && p->splitchar == 0)
        srcharr[srchtop++] = (char *)p->eqkid;
    if (*s == '.' || *s > p->splitchar)
        pmsearch(p->hikid, s);
}

void nearsearch(Tptr p, char *s, int d)
{
    if (!p || d < 0)
        return;
    nodecnt++;
    if (d > 0 || *s < p->splitchar)
        nearsearch(p->lokid, s, d);
    if (p->splitchar == 0)
    {
        if ((int)strlen(s) <= d)
            srcharr[srchtop++] = (char *)p->eqkid;
    }
    else
        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);
    if (d > 0 || *s > p->splitchar)
        nearsearch(p->hikid, s, d);
}

#define NUMBER_OF_STRING 3

int main(int argc, char *argv[])
{
    char *arr[NUMBER_OF_STRING] = {"apple", "cat", "boy"};

    ssort1main(arr, NUMBER_OF_STRING);

    for (int i = 0; i < NUMBER_OF_STRING; i++)
    {
        printf("%s ", arr[i]);
    }
}
#include <stdio.h>
#include <stdlib.h>


void flip(int arr[], int i)
{
    int temp, start = 0;

    while (start < i)
    {
        temp = arr[start];
        arr[start] = arr[i];
        arr[i] = temp;
        start++;
        i--;
    }
}

int findMax(int arr[], int n)
{
    int maxElementIdx, i;

    for (maxElementIdx = 0, i = 0; i < n; ++i)
        if (arr[i] > arr[maxElementIdx])
            maxElementIdx = i;

    return maxElementIdx;
}

void pancakeSort(int *arr, int n)
{
        for (int curr_size = n; curr_size > 1; --curr_size)
    {
                int maxElementIdx = findMax(arr, curr_size);

                        if (maxElementIdx != curr_size - 1)
        {
                        flip(arr, maxElementIdx);

                        flip(arr, curr_size - 1);
        }
    }
}

void display(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

#define N 50

int main()
{
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % (N << 1); 

    printf("Original array: ");
    display(arr, N);

    pancakeSort(arr, N);
    printf("Sorted array: ");
    display(arr, N);

    return 0;
}#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int arr[], int low, int high)
{
    int pivot = arr[low];
    int i = low - 1, j = high + 1;

    while (1)
    {
        
        do
        {
            i++;
        } while (arr[i] < pivot);

        
        do
        {
            j--;
        } while (arr[j] > pivot);

        
        if (i >= j)
            return j;

        swap(&arr[i], &arr[j]);
    }
}

void partitionSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int value = partition(arr, low, high);
        partitionSort(arr, low, value);
        partitionSort(arr, value + 1, high);
    }
}

void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
}

int main()
{
    int arr[20];
    int i, range = 100;
    for (i = 0; i < 20; i++)
    {
        arr[i] = rand() % range + 1;
    }
    int size = sizeof arr / sizeof arr[0];
    printf("Array: \n");
    printArray(arr, size);
    partitionSort(arr, 0, size - 1);
    printf("Sorted Array: \n");
    printArray(arr, size);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void pigeonholeSort(int arr[], int size)
{
    int i, j, min = arr[0], max = arr[0], range;

        for (i = 1; i < size; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }
    range = max - min + 1;

        int *holes = (int *)malloc(sizeof(int) * range);
    for (i = 0; i < range; i++)
    {
        holes[i] = 0;
    }
    for (i = 0; i < size; i++)
    {
        holes[arr[i] - min]++;
    }

        j = 0;
    for (i = 0; i < range; i++)
    {
        while (holes[i] > 0)
        {
            arr[j] = i + min;
            holes[i]--;
            j++;
        }
    }

    free(holes);
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    pigeonholeSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}#include <stdio.h>
#include <stdlib.h>


void display(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}


void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}


int partition(int arr[], int lower, int upper)
{
    int i = (lower - 1);

    int pivot = arr[upper];  
    int j;
    for (j = lower; j < upper; j++)
    {
        if (arr[j] <= pivot)
        {  
            i++;              swap(&arr[i], &arr[j]);
        }
    }

    swap(&arr[i + 1], &arr[upper]);                                       
    return (i + 1);
}


void quickSort(int arr[], int lower, int upper)
{
    if (upper > lower)
    {
                
        int partitionIndex = partition(arr, lower, upper);

                quickSort(arr, lower, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, upper);
    }
}

int main()
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(sizeof(int) * n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  
    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    display(arr, n);      getchar();
    return 0;
}
#include <stdio.h>

int largest(int a[], int n)
{
    int large = a[0], i;
    for (i = 1; i < n; i++)
    {
        if (large < a[i])
            large = a[i];
    }
    return large;
}

void RadixSort(int a[], int n)
{
    int bucket[10][10], bucket_count[10];
    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;

    large = largest(a, n);
    printf("The large element %d\n", large);
    while (large > 0)
    {
        NOP++;
        large /= 10;
    }

    for (pass = 0; pass < NOP; pass++)
    {
        for (i = 0; i < 10; i++)
        {
            bucket_count[i] = 0;
        }
        for (i = 0; i < n; i++)
        {
            remainder = (a[i] / divisor) % 10;
            bucket[remainder][bucket_count[remainder]] = a[i];
            bucket_count[remainder] += 1;
        }

        i = 0;
        for (k = 0; k < 10; k++)
        {
            for (j = 0; j < bucket_count[k]; j++)
            {
                a[i] = bucket[k][j];
                i++;
            }
        }
        divisor *= 10;

        for (i = 0; i < n; i++) printf("%d  ", a[i]);
        printf("\n");
    }
}

int main()
{
    int i, n, a[10];
    printf("Enter the number of elements :: ");
    scanf("%d", &n);
    printf("Enter the elements :: ");
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }
    RadixSort(a, n);
    printf("The sorted elements are ::  ");
    for (i = 0; i < n; i++) printf("%d  ", a[i]);
    printf("\n");
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define range 10  
int MAX(int *ar, int size)
{
    int i, max = ar[0];
    for (i = 0; i < size; i++)
    {
        if (ar[i] > max)
            max = ar[i];
    }
    return max;
}

void countSort(int *arr, int n, int place)
{
    int i, freq[range] = {0};
    int *output = (int *)malloc(n * sizeof(int));

        for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;

            for (i = 1; i < range; i++) freq[i] += freq[i - 1];

        for (i = n - 1; i >= 0; i--)
    {
        output[freq[(arr[i] / place) % range] - 1] = arr[i];
        freq[(arr[i] / place) % range]--;
    }

            for (i = 0; i < n; i++) arr[i] = output[i];
    free(output);
}


void radixsort2(int *arr, int n,
                int max)  {
    int mul = 1;
    while (max)
    {
        countSort(arr, n, mul);
        mul *= 10;
        max /= 10;
    }
}

void display(int *arr, int N)
{
    for (int i = 0; i < N; i++) printf("%d, ", arr[i]);
    putchar('\n');
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  
    int max;
    max = MAX(arr, n);

    radixsort2(arr, n, max);

    printf("Sorted array: ");
    display(arr, n);  
    free(arr);
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int getBig(int *a, int i, int right, int pivot)
{
    for (int k = i; k <= right; k++)
    {
        if (a[k] > pivot)
            return k;
    }
    return right + 1;
}

int getSmall(int *a, int j, int left, int pivot)
{
    for (int k = j; k >= left; k--)
    {
        if (a[k] < pivot)
            return k;
    }
    return -1;
}

void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

void random_quick(int *a, int left, int right)
{
    if (left >= right)
        return;
    int index = left + (rand() % (right - left)), i = left, j = right;
    int pivot_index = index;
    int pivot = a[index];
        i = getBig(a, i, right, pivot);
        j = getSmall(a, j, left, pivot);
    while (i <= j)
    {
        swap(&a[i], &a[j]);
        i = getBig(a, i, right, pivot);
        j = getSmall(a, j, left, pivot);
    }
            if (pivot_index > j && pivot_index > i)
    {
                swap(&a[i], &a[pivot_index]);
        random_quick(a, left, i - 1);
        random_quick(a, i + 1, right);
    }
    else if (pivot_index < j && pivot_index < i)
    {
                swap(&a[j], &a[pivot_index]);
        random_quick(a, left, j - 1);
        random_quick(a, j + 1, right);
    }
    else
    {
                random_quick(a, left, pivot_index - 1);
        random_quick(a, pivot_index + 1, right);
    }
}

int main()
{
    srand(time(0));
    int num;
    scanf("%d", &num);
    int *arr = (int *)malloc(num * sizeof(int));
    for (int i = 0; i < num; i++)
    {
        scanf("%d", &arr[i]);
    }
    random_quick(arr, 0, num - 1);
    for (int i = 0; i < num; i++)
    {
        printf("%d ", arr[i]);
    }

    free(arr);
    printf("\n");
}
#include <stdio.h>
#include <stdlib.h>


void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}


void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}


void selectionSort(int *arr, int size)
{
    for (int i = 0; i < size; i++)
    {
        int min_index = i;
        for (int j = i + 1; j < size; j++)
        {
            if (arr[min_index] > arr[j])
            {
                min_index = j;
            }
        }
        swap(&arr[i], &arr[min_index]);
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  
    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  
    selectionSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);  
    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
void shakersort(int *a, int n)
{
    int p, i;
    for (p = 1; p <= n / 2; p++)
    {
        for (i = p - 1; i < n - p; i++)
            if (a[i] > a[i + 1])
            {
                swap(&a[i], &a[i + 1]);
            }
        for (i = n - p - 1; i >= p; i--)
            if (a[i] < a[i - 1])
            {
                swap(&a[i], &a[i - 1]);
            }
    }
}
int main()
{
    int n;
    scanf("%d", &n);
    int *arr = (int *)malloc(n * sizeof(int));
    int i;
    for (i = 0; i < n; i++) scanf("%d ", &arr[i]);
    shakersort(arr, n);
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ELEMENT_NR 20000
#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))
const char *notation =
    "Shell Sort Big O Notation:\
						\n--> Best Case: O(n log(n)) \
						\n--> Average Case: depends on gap sequence \
						\n--> Worst Case: O(n)";

void show_data(int arr[], int len)
{
    int i;

    for (i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}

void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

void shellSort(int array[], int len)
{
    int i, j, gap;

    for (gap = len / 2; gap > 0; gap = gap / 2)
        for (i = gap; i < len; i++)
            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)
                swap(&array[j], &array[j + gap]);
}

int main(int argc, char *argv[])
{
    int i;
    int array[ELEMENT_NR];
    int range = 500;
    int size;
    clock_t start, end;
    double time_spent;

    srand(time(NULL));
    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;

    size = ARRAY_LEN(array);

    show_data(array, size);
    start = clock();
    shellSort(array, size);
    end = clock();
    time_spent = (double)(end - start) / CLOCKS_PER_SEC;

    printf("Data Sorted\n");
    show_data(array, size);

    printf("%s\n", notation);
    printf("Time spent sorting: %.4g ms\n", time_spent * 1e3);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <time.h>



void show_data(int *arr, long len)
{
    for (long i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}


inline void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}


void shell_sort(int *array, long LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    long i, j, g;

    for (g = 0; g < gap_len; g++)
    {          int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {              int tmp = array[i];

            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)
                array[j] = array[j - gap];
            array[j] = tmp;
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}



int main(int argc, char *argv[])
{
    int i;
    long size = 500;
    if (argc == 2)
        size = atol(argv[1]);
    else if (argc > 2)
        fprintf(stderr, "Usage: ./shell_sort [number of values]\n");

    int *array = (int *)malloc(size * sizeof(int));
    int range = 500;      double time_spent;

    srand(time(NULL));      for (i = 0; i < size; i++)
                array[i] = rand() % range + 1;

    show_data(array, size);       clock_t t1 = clock();         shell_sort(array, size);      clock_t t2 = clock();     
    printf("Data Sorted\n");
    show_data(array, size);  
    printf("Time spent sorting: %.4g s\n", (t2 - t1) / CLOCKS_PER_SEC);

    free(array);
    return 0;
}
#include <stdio.h>
void stoogesort(int[], int, int);

int main()
{
    int arr[100], i, n;

    printf("How many elements do you want to sort: ");
    scanf("%d", &n);
    for (i = 0; i < n; i++) scanf(" %d", &arr[i]);
    stoogesort(arr, 0, n - 1);
    printf("Sorted array : \n");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}

void stoogesort(int arr[], int i, int j)
{
    int temp, k;
    if (arr[i] > arr[j])
    {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    if ((i + 1) >= j)
        return;
    k = (int)((j - i + 1) / 3);
    stoogesort(arr, i, j - k);
    stoogesort(arr, i + k, j);
    stoogesort(arr, i, j - k);
}
